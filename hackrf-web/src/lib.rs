use rustfft::num_complex::Complex;
use rustfft::FftPlanner;
use std::f32::consts::PI;
use std::slice;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

#[allow(unused_macros)]
macro_rules! console_log {
    // Note that this is using the `log` function imported above during
    // `bare_bones`
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

#[wasm_bindgen]
pub fn set_panic_hook() {
    console_error_panic_hook::set_once();
}

#[wasm_bindgen]
pub struct FFT {
    n: usize,
    smoothing_speed: f32,
    fft: std::sync::Arc<dyn rustfft::Fft<f32>>,
    prev: Box<[f32]>,
    /// FFT working buffer. Reused to avoid allocations
    buffer: Vec<rustfft::num_complex::Complex<f32>>,
    /// Window function with pre-applied scaling (1/128 and 1/n)
    scaled_window: Box<[f32]>,
}

#[wasm_bindgen]
impl FFT {
    /// Create a new FFT processor.
    ///
    /// # Arguments
    /// * `n` - FFT size. Must be a power of two and greater than 0
    /// * `window_` - Window function array. Length must equal `n`
    ///
    /// # Panics
    /// * If `n` is 0
    /// * If `n` is not a power of two
    /// * If `window_.len() != n`
    #[allow(clippy::new_without_default)]
    #[wasm_bindgen(constructor)]
    pub fn new(n: usize, window_: &[f32]) -> Self {
        assert!(n > 0, "FFT size must be positive, got {}", n);
        assert!(n.is_power_of_two(), "FFT size must be a power of two, got {}", n);
        assert_eq!(window_.len(), n, "Window size must match FFT size (expected {}, got {})", n, window_.len());

        let fft = FftPlanner::new().plan_fft_forward(n);
        let prev = vec![0.0; n].into_boxed_slice();
        let smoothing_speed = 1.0;
        let buffer = vec![Complex { re: 0.0, im: 0.0 }; n];

        // Pre-apply scaling factors to window function
        // 1/128: normalize i8 (-128..127) to -1..1
        // (-1)^i: pre-FFT DC centering (equivalent to fftShift, matches SDR++ iq_frontend.cpp)
        let scale = 1.0 / 128.0;
        let scaled_window = window_.iter().enumerate().map(|(i, &w)| {
            let shift = if i % 2 == 0 { 1.0f32 } else { -1.0f32 };
            w * scale * shift
        }).collect::<Vec<_>>().into_boxed_slice();

        FFT {
            n,
            smoothing_speed,
            fft,
            prev,
            buffer,
            scaled_window,
        }
    }

    pub fn set_smoothing_speed(&mut self, val: f32) {
        self.smoothing_speed = val;
    }

    /// Perform a complex FFT on HackRF One IQ samples and apply all
    /// preprocessing needed for spectrogram waterfall display.
    ///
    /// This method performs the following operations in a single pass:
    /// 1. Normalize IQ samples (i8 → f32)
    /// 2. Apply window function
    /// 3. Complex FFT
    /// 4. Rearrange frequency axis to DC-centered layout
    /// 5. Exponential moving average smoothing (when configured)
    /// 6. Convert to dB scale
    ///
    /// The output array can be used directly as a single row (spectrum at time t)
    /// in a waterfall spectrogram display.
    ///
    /// # Input format
    /// * `input_` - Complex sequence as i8 array `[re0, im0, re1, im1, ...]`
    ///               Length must be `self.n * 2`
    ///
    /// # Output format
    /// * `result` - Buffer to store results. Length must be `self.n`
    ///   - `result[0 .. half_n]` - Negative frequency components (DC-centered, dB scale)
    ///   - `result[half_n .. n]` - Positive frequency components (DC-centered, dB scale)
    ///
    /// # Contract (caller's responsibility)
    /// * `input_.len() == self.n * 2` must hold
    /// * `result.len() == self.n` must hold
    ///
    /// # Safety
    /// This function uses unsafe memory reinterpretation. Violating the contract
    /// may cause undefined behavior.
    pub fn fft(&mut self, input_: &[i8], result: &mut [f32]) {
        debug_assert_eq!(input_.len(), self.n * 2, "Input length must be n * 2");
        debug_assert_eq!(result.len(), self.n, "Result length must be n");

        // Reinterpret i8 array [re0, im0, re1, im1, ...] as a Complex<i8> slice
        let input_complex: &[Complex<i8>] = unsafe {
            slice::from_raw_parts(input_.as_ptr() as *const Complex<i8>, self.n)
        };

        // Working buffer (stored in struct for reuse, avoiding allocations)
        let buffer = &mut self.buffer;

        // Normalize and apply window function. scaled_window includes 1/128 and 1/n scaling.
        for i in 0..self.n {
            buffer[i] = Complex {
                re: input_complex[i].re as f32,
                im: input_complex[i].im as f32,
            } * self.scaled_window[i];
        }

        // Execute FFT (in-place transform)
        self.fft.process(buffer);

        // Combined into a single pass (matches SDR++ iq_frontend.cpp + waterfall.cpp):
        // 1. DC centering already done via (-1)^i in window (pre-FFT shift)
        // 2. Power spectrum: 10 * log10(re² + im²) (matches volk_32fc_s32f_power_spectrum_32f)
        // 3. Exponential moving average smoothing in dB domain
        let alpha = self.smoothing_speed;
        let inv_alpha = 1.0 - alpha;

        for i in 0..self.n {
            // Power spectrum calculating exactly as `volk_32fc_s32f_power_spectrum_32f`
            // with `_fftSize` passed as the `normalization_factor` like in SDR++
            let power = buffer[i].norm_sqr() / (self.n as f32);
            let db = power.max(1e-20).log10() * 10.0;

            // EMA smoothing in dB domain (matches SDR++ waterfall.cpp pushFFT)
            // SDR++ formula: result = alpha * new + (1-alpha) * old
            // alpha = speed: 1.0 = no smoothing, 0.0 = frozen
            result[i] = if alpha < 1.0 {
                let s = alpha * db + inv_alpha * self.prev[i];
                self.prev[i] = s;
                s
            } else {
                db
            };
        }
    }
}

// ============================================================================
// DSP Primitives (matching SDR++ core/src/dsp/)
// ============================================================================

/// Cosine window (matches SDR++ dsp/window/cosine.h)
/// n: continuous offset value, big_n: window length N
fn cosine_window(n: f64, big_n: f64, coefs: &[f64]) -> f64 {
    let mut win = 0.0;
    let mut sign = 1.0;
    for (i, &c) in coefs.iter().enumerate() {
        win += sign * c * (i as f64 * 2.0 * std::f64::consts::PI * n / big_n).cos();
        sign = -sign;
    }
    win
}

/// Nuttall 4-term cosine window (matches SDR++ dsp/window/nuttall.h)
/// n: continuous offset value, big_n: window length N
fn nuttall_window(n: f64, big_n: f64) -> f64 {
    const COEFS: [f64; 4] = [0.355768, 0.487396, 0.144232, 0.012604];
    cosine_window(n, big_n, &COEFS)
}

/// sinc(x) = sin(x)/x, sinc(0) = 1
fn sinc(x: f64) -> f64 {
    if x.abs() < 1e-12 {
        1.0
    } else {
        x.sin() / x
    }
}

/// Estimate FIR tap count (matches SDR++ dsp/taps/estimate_tap_count.h)
fn estimate_tap_count(trans_width: f64, sample_rate: f64) -> usize {
    (3.8 * sample_rate / trans_width).floor() as usize
}

/// Generate low-pass FIR taps using windowed sinc with Nuttall window
/// (matches SDR++ dsp/taps/low_pass.h + dsp/taps/windowed_sinc.h)
fn low_pass_taps(cutoff: f64, trans_width: f64, sample_rate: f64) -> Vec<f32> {
    let count = estimate_tap_count(trans_width, sample_rate).max(1);
    let omega = 2.0 * std::f64::consts::PI * cutoff / sample_rate;
    let half = count as f64 / 2.0;
    let corr = omega / std::f64::consts::PI;
    let mut taps = Vec::with_capacity(count);
    for i in 0..count {
        let t = i as f64 - half + 0.5;
        // SDR++ windowed_sinc.h passes (t - half, count) to window function
        let win = nuttall_window(t - half, count as f64);
        let val = sinc(t * omega) * win * corr;
        taps.push(val as f32);
    }
    taps
}

/// Greatest common divisor
fn gcd(mut a: usize, mut b: usize) -> usize {
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}

// ============================================================================
// SDR++ PowerDecimator — pre-computed optimized FIR decimation plans
// (matches SDR++ dsp/multirate/power_decimator.h + decim/plans.h)
//
// These tap coefficients are auto-generated by an optimized plan algo
// (see SDR++ source). Each plan cascades 1-4 DecimatingFIR stages to
// achieve the target power-of-2 decimation ratio with proper anti-aliasing.
// ============================================================================

// ── Tap coefficients (matches SDR++ dsp/multirate/decim/taps/) ──────────────

/// 69-tap decimation-by-2 filter
const FIR_2_2: &[f32] = &[
    0.000400633624864, 0.002075598505552, 0.004856364956715, 0.005979016698235,
    0.002622922607902,-0.002718259152577,-0.003381533671376, 0.001638638539759,
    0.004081814705993,-0.000984029228217,-0.005120988470135, 0.000177440907285,
    0.006425852662023, 0.001009351602305,-0.007912827910006,-0.002713700675199,
    0.009509311257450, 0.005070635723474,-0.011154020477109,-0.008246059919867,
    0.012785716787299, 0.012487906837156,-0.014347452386709,-0.018205770848481,
    0.015781858576801, 0.026172374716730,-0.017037643409603,-0.038051489304887,
    0.018067070624730, 0.058212412671604,-0.018832304184135,-0.102772486604899,
    0.019303165035556, 0.317189488733641, 0.480537520090363, 0.317189488733641,
    0.019303165035556,-0.102772486604899,-0.018832304184135, 0.058212412671604,
    0.018067070624730,-0.038051489304887,-0.017037643409603, 0.026172374716730,
    0.015781858576801,-0.018205770848481,-0.014347452386709, 0.012487906837156,
    0.012785716787299,-0.008246059919867,-0.011154020477109, 0.005070635723474,
    0.009509311257450,-0.002713700675199,-0.007912827910006, 0.001009351602305,
    0.006425852662023, 0.000177440907285,-0.005120988470135,-0.000984029228217,
    0.004081814705993, 0.001638638539759,-0.003381533671376,-0.002718259152577,
    0.002622922607902, 0.005979016698235, 0.004856364956715, 0.002075598505552,
    0.000400633624864,
];

/// 12-tap decimation-by-2 (used after 4x overall decimation)
const FIR_4_2: &[f32] = &[
    -0.003856211869499,-0.022330421420748,-0.042348797151517, 0.009330574289172,
     0.182544215014523, 0.363014696342451, 0.363014696342451, 0.182544215014523,
     0.009330574289172,-0.042348797151517,-0.022330421420748,-0.003856211869499,
];

/// 27-tap decimation-by-4
const FIR_8_4: &[f32] = &[
    -0.000069910742154,-0.000552526802288,-0.002127088129249,-0.005633575976279,
    -0.011315295341167,-0.017735691906137,-0.021011120930551,-0.015296134618958,
     0.005014080997102, 0.041970748926553, 0.091347535728189, 0.142430310818233,
     0.181170927236212, 0.195642275183578, 0.181170927236212, 0.142430310818233,
     0.091347535728189, 0.041970748926553, 0.005014080997102,-0.015296134618958,
    -0.021011120930551,-0.017735691906137,-0.011315295341167,-0.005633575976279,
    -0.002127088129249,-0.000552526802288,-0.000069910742154,
];

/// 54-tap decimation-by-8
const FIR_16_8: &[f32] = &[
    -0.000010549050011,-0.000061489537039,-0.000169592150226,-0.000389171926135,
    -0.000769975911674,-0.001370854592385,-0.002239650734147,-0.003399889102518,
    -0.004830705343877,-0.006448446354249,-0.008091855414668,-0.009515841436220,
    -0.010397441921856,-0.010356613271974,-0.008992201469341,-0.005930787518203,
    -0.000883278427221, 0.006298245739840, 0.015572308400311, 0.026677311102094,
     0.039125595948408, 0.052226522148894, 0.065138644768753, 0.076946519590666,
     0.086753453366436, 0.093778448420600, 0.097444265291570, 0.097444265291570,
     0.093778448420600, 0.086753453366436, 0.076946519590666, 0.065138644768753,
     0.052226522148894, 0.039125595948408, 0.026677311102094, 0.015572308400311,
     0.006298245739840,-0.000883278427221,-0.005930787518203,-0.008992201469341,
    -0.010356613271974,-0.010397441921856,-0.009515841436220,-0.008091855414668,
    -0.006448446354249,-0.004830705343877,-0.003399889102518,-0.002239650734147,
    -0.001370854592385,-0.000769975911674,-0.000389171926135,-0.000169592150226,
    -0.000061489537039,-0.000010549050011,
];

/// 44-tap decimation-by-8
const FIR_32_8: &[f32] = &[
    -0.000029744589241,-0.000102805435515,-0.000256933218578,-0.000524425617107,
    -0.000923167111410,-0.001434928315096,-0.001981567015438,-0.002404088713278,
    -0.002451791426948,-0.001788676228348,-0.000022184036340, 0.003244839156945,
     0.008343584867029, 0.015460483392566, 0.024564907542072, 0.035359785525755,
     0.047269560715908, 0.059474265224980, 0.070989991387120, 0.080786468196769,
     0.087923948445323, 0.091686274752633, 0.091686274752633, 0.087923948445323,
     0.080786468196769, 0.070989991387120, 0.059474265224980, 0.047269560715908,
     0.035359785525755, 0.024564907542072, 0.015460483392566, 0.008343584867029,
     0.003244839156945,-0.000022184036340,-0.001788676228348,-0.002451791426948,
    -0.002404088713278,-0.001981567015438,-0.001434928315096,-0.000923167111410,
    -0.000524425617107,-0.000256933218578,-0.000102805435515,-0.000029744589241,
];

/// 36-tap decimation-by-8
const FIR_64_8: &[f32] = &[
     0.000015230923996, 0.000082077920191, 0.000262521513750, 0.000673128659394,
     0.001475675202716, 0.002887947811052, 0.005159198622906, 0.008543963462691,
     0.013252097427442, 0.019396810069284, 0.026940321432500, 0.035656237803203,
     0.045115851141008, 0.054709465624648, 0.063702603363867, 0.071322539438903,
     0.076861237718122, 0.079777267801515, 0.079777267801515, 0.076861237718122,
     0.071322539438903, 0.063702603363867, 0.054709465624648, 0.045115851141008,
     0.035656237803203, 0.026940321432500, 0.019396810069284, 0.013252097427442,
     0.008543963462691, 0.005159198622906, 0.002887947811052, 0.001475675202716,
     0.000673128659394, 0.000262521513750, 0.000082077920191, 0.000015230923996,
];

/// 72-tap decimation-by-16
const FIR_128_16: &[f32] = &[
     0.000003688211243, 0.000013660745184, 0.000027864244875, 0.000056024595736,
     0.000099948148808, 0.000168552197041, 0.000269382284025, 0.000413325712010,
     0.000612084815649, 0.000879405538662, 0.001230104825804, 0.001680092905716,
     0.002245658820654, 0.002942957882659, 0.003787212583021, 0.004791922493325,
     0.005967969572298, 0.007322738536994, 0.008859256322921, 0.010575423925694,
     0.012463379308760, 0.014509046778473, 0.016691912242846, 0.018985060458242,
     0.021355495646189, 0.023764754477139, 0.026169804021396, 0.028524201614471,
     0.030779477612194, 0.032886687871454, 0.034798070863046, 0.036468735790737,
     0.037858303447209, 0.038932421304764, 0.039664078609141, 0.040034655893826,
     0.040034655893826, 0.039664078609141, 0.038932421304764, 0.037858303447209,
     0.036468735790737, 0.034798070863046, 0.032886687871454, 0.030779477612194,
     0.028524201614471, 0.026169804021396, 0.023764754477139, 0.021355495646189,
     0.018985060458242, 0.016691912242846, 0.014509046778473, 0.012463379308760,
     0.010575423925694, 0.008859256322921, 0.007322738536994, 0.005967969572298,
     0.004791922493325, 0.003787212583021, 0.002942957882659, 0.002245658820654,
     0.001680092905716, 0.001230104825804, 0.000879405538662, 0.000612084815649,
     0.000413325712010, 0.000269382284025, 0.000168552197041, 0.000099948148808,
     0.000056024595736, 0.000027864244875, 0.000013660745184, 0.000003688211243,
];

/// 143-tap decimation-by-32
const FIR_256_32: &[f32] = &[
     0.000002024710441, 0.000005071986063, 0.000005649621619, 0.000009996317351,
     0.000013960233561, 0.000020203028684, 0.000027743453140, 0.000037649365146,
     0.000049946026699, 0.000065301488097, 0.000084113029863, 0.000107006458486,
     0.000134566059018, 0.000167482006932, 0.000206469601804, 0.000252311382077,
     0.000305831073218, 0.000367903193892, 0.000439441775093, 0.000521398892491,
     0.000614756278678, 0.000720519104213, 0.000839706996025, 0.000973345013002,
     0.001122453164999, 0.001288035337090, 0.001471067271555, 0.001672483946636,
     0.001893166344323, 0.002133927814945, 0.002395500153619, 0.002678519576086,
     0.002983512762124, 0.003310883161302, 0.003660897754233, 0.004033674471928,
     0.004429170475222, 0.004847171495793, 0.005287282435142, 0.005748919410995,
     0.006231303428249, 0.006733455837854, 0.007254195729720, 0.007792139384731,
     0.008345701888126, 0.008913100980819, 0.009492363197372, 0.010081332310191,
     0.010677680068163, 0.011278919186999, 0.011882418516063, 0.012485420274634,
     0.013085059219684, 0.013678383576860, 0.014262377537964, 0.014833985102374,
     0.015390135015749, 0.015927766539308, 0.016443855765594, 0.016935442183430,
     0.017399655185551, 0.017833740207285, 0.018235084184538, 0.018601240022499,
     0.018929949775865, 0.019219166253362, 0.019467072776985, 0.019672100847465,
     0.019832945492079, 0.019948578099591, 0.020018256578123, 0.020041532705549,
     0.020018256578123, 0.019948578099591, 0.019832945492079, 0.019672100847465,
     0.019467072776985, 0.019219166253362, 0.018929949775865, 0.018601240022499,
     0.018235084184538, 0.017833740207285, 0.017399655185551, 0.016935442183430,
     0.016443855765594, 0.015927766539308, 0.015390135015749, 0.014833985102374,
     0.014262377537964, 0.013678383576860, 0.013085059219684, 0.012485420274634,
     0.011882418516063, 0.011278919186999, 0.010677680068163, 0.010081332310191,
     0.009492363197372, 0.008913100980819, 0.008345701888126, 0.007792139384731,
     0.007254195729720, 0.006733455837854, 0.006231303428249, 0.005748919410995,
     0.005287282435142, 0.004847171495793, 0.004429170475222, 0.004033674471928,
     0.003660897754233, 0.003310883161302, 0.002983512762124, 0.002678519576086,
     0.002395500153619, 0.002133927814945, 0.001893166344323, 0.001672483946636,
     0.001471067271555, 0.001288035337090, 0.001122453164999, 0.000973345013002,
     0.000839706996025, 0.000720519104213, 0.000614756278678, 0.000521398892491,
     0.000439441775093, 0.000367903193892, 0.000305831073218, 0.000252311382077,
     0.000206469601804, 0.000167482006932, 0.000134566059018, 0.000107006458486,
     0.000084113029863, 0.000065301488097, 0.000049946026699, 0.000037649365146,
     0.000027743453140, 0.000020203028684, 0.000013960233561, 0.000009996317351,
     0.000005649621619, 0.000005071986063, 0.000002024710441,
];

/// 129-tap decimation-by-32
const FIR_512_32: &[f32] = &[
     0.000008540968797, 0.000009922400188, 0.000015550948353, 0.000023167181508,
     0.000033231811476, 0.000046270708161, 0.000062878000273, 0.000083718456393,
     0.000109529013922, 0.000141119329083, 0.000179371225499, 0.000225236929029,
     0.000279735987160, 0.000343950788528, 0.000419020613557, 0.000506134170029,
     0.000606520589550, 0.000721438886986, 0.000852165912394, 0.000999982852844,
     0.001166160372943, 0.001351942511872, 0.001558529485270, 0.001787059568999,
     0.002038590271450, 0.002314079024704, 0.002614363649958, 0.002940142872027,
     0.003291957174154, 0.003670170297288, 0.004074951693870, 0.004506260250540,
     0.004963829590056, 0.005447155254368, 0.005955484057066, 0.006487805874260,
     0.007042848116484, 0.007619073095444, 0.008214678463585, 0.008827600864209,
     0.009455522888034, 0.010095883384323, 0.010745891124847, 0.011402541770574,
     0.012062638037206, 0.012722812904219, 0.013379555663224, 0.014029240550834,
     0.014668157666599, 0.015292545833545, 0.015898627022289, 0.016482641925719,
     0.017040886246767, 0.017569747239682, 0.018065740033662, 0.018525543262431,
     0.018946033522759, 0.019324318198100, 0.019657766196845, 0.019944036181861,
     0.020181101897746, 0.020367274240763, 0.020501219760524, 0.020581975330434,
     0.020608958779118, 0.020581975330434, 0.020501219760524, 0.020367274240763,
     0.020181101897746, 0.019944036181861, 0.019657766196845, 0.019324318198100,
     0.018946033522759, 0.018525543262431, 0.018065740033662, 0.017569747239682,
     0.017040886246767, 0.016482641925719, 0.015898627022289, 0.015292545833545,
     0.014668157666599, 0.014029240550834, 0.013379555663224, 0.012722812904219,
     0.012062638037206, 0.011402541770574, 0.010745891124847, 0.010095883384323,
     0.009455522888034, 0.008827600864209, 0.008214678463585, 0.007619073095444,
     0.007042848116484, 0.006487805874260, 0.005955484057066, 0.005447155254368,
     0.004963829590056, 0.004506260250540, 0.004074951693870, 0.003670170297288,
     0.003291957174154, 0.002940142872027, 0.002614363649958, 0.002314079024704,
     0.002038590271450, 0.001787059568999, 0.001558529485270, 0.001351942511872,
     0.001166160372943, 0.000999982852844, 0.000852165912394, 0.000721438886986,
     0.000606520589550, 0.000506134170029, 0.000419020613557, 0.000343950788528,
     0.000279735987160, 0.000225236929029, 0.000179371225499, 0.000141119329083,
     0.000109529013922, 0.000083718456393, 0.000062878000273, 0.000046270708161,
     0.000033231811476, 0.000023167181508, 0.000015550948353, 0.000009922400188,
     0.000008540968797,
];

/// 257-tap decimation-by-64
const FIR_1024_64: &[f32] = &[
     0.000006462031529, 0.000003762409463, 0.000004844873785, 0.000006123946040,
     0.000007623557621, 0.000009369500189, 0.000011389489511, 0.000013713225713,
     0.000016372450007, 0.000019400995965, 0.000022834836357, 0.000026712124166,
     0.000031073227314, 0.000035960757034, 0.000041419588684, 0.000047496875380,
     0.000054242053050, 0.000061706837053, 0.000069945209697, 0.000079013398311,
     0.000088969843345, 0.000099875155888, 0.000111792065160, 0.000124785354321,
     0.000138921785260, 0.000154270012137, 0.000170900482798, 0.000188885328279,
     0.000208298240660, 0.000229214338496, 0.000251710020027, 0.000275862804808,
     0.000301751162750, 0.000329454331625, 0.000359052122812, 0.000390624715628,
     0.000424252440518, 0.000460015551653, 0.000497993989069, 0.000538267130868,
     0.000580913536707, 0.000626010681838, 0.000673634683977, 0.000723860022294,
     0.000776759250136, 0.000832402702294, 0.000890858197110, 0.000952190735149,
     0.001016462194703, 0.001083731025617, 0.001154051942217, 0.001227475616900,
     0.001304048374716, 0.001383811890755, 0.001466802891491, 0.001553052860930,
     0.001642587753007, 0.001735427711423, 0.001831586798359, 0.001931072732585,
     0.002033886639476, 0.002140022812541, 0.002249468489330, 0.002362203641302,
     0.002478200780155, 0.002597424780897, 0.002719832722953, 0.002845373750630,
     0.002973988953416, 0.003105611267477, 0.003240165399026, 0.003377567770453,
     0.003517726489639, 0.003660541344023, 0.003805903818490, 0.003953697139430,
     0.004103796343600, 0.004256068373481, 0.004410372198649, 0.004566558963662,
     0.004724472161982, 0.004883947836741, 0.005044814807351, 0.005206894922255,
     0.005370003337046, 0.005533948818282, 0.005698534071229, 0.005863556091925,
     0.006028806542319, 0.006194072147902, 0.006359135116484, 0.006523773577483,
     0.006687762040265, 0.006850871870724, 0.007012871784157, 0.007173528353865,
     0.007332606533364, 0.007489870190776, 0.007645082654370, 0.007798007266777,
     0.007948407946740, 0.008096049756555, 0.008240699473269, 0.008382126161983,
     0.008520101749207, 0.008654401594640, 0.008784805059577, 0.008911096069443,
     0.009033063669314, 0.009150502570440, 0.009263213685289, 0.009371004650260,
     0.009473690333377, 0.009571093325806, 0.009663044415454, 0.009749383040556,
     0.009829957722201, 0.009904626474092, 0.009973257187859, 0.010035727993149,
     0.010091927590538, 0.010141755556416, 0.010185122619096, 0.010221950904489,
     0.010252174150955, 0.010275737892470, 0.010292599609103, 0.010302728845123,
     0.010306107293174, 0.010302728845123, 0.010292599609103, 0.010275737892470,
     0.010252174150955, 0.010221950904489, 0.010185122619096, 0.010141755556416,
     0.010091927590538, 0.010035727993149, 0.009973257187859, 0.009904626474092,
     0.009829957722201, 0.009749383040556, 0.009663044415454, 0.009571093325806,
     0.009473690333377, 0.009371004650260, 0.009263213685289, 0.009150502570440,
     0.009033063669314, 0.008911096069443, 0.008784805059577, 0.008654401594640,
     0.008520101749207, 0.008382126161983, 0.008240699473269, 0.008096049756555,
     0.007948407946740, 0.007798007266777, 0.007645082654370, 0.007489870190776,
     0.007332606533364, 0.007173528353865, 0.007012871784157, 0.006850871870724,
     0.006687762040265, 0.006523773577483, 0.006359135116484, 0.006194072147902,
     0.006028806542319, 0.005863556091925, 0.005698534071229, 0.005533948818282,
     0.005370003337046, 0.005206894922255, 0.005044814807351, 0.004883947836741,
     0.004724472161982, 0.004566558963662, 0.004410372198649, 0.004256068373481,
     0.004103796343600, 0.003953697139430, 0.003805903818490, 0.003660541344023,
     0.003517726489639, 0.003377567770453, 0.003240165399026, 0.003105611267477,
     0.002973988953416, 0.002845373750630, 0.002719832722953, 0.002597424780897,
     0.002478200780155, 0.002362203641302, 0.002249468489330, 0.002140022812541,
     0.002033886639476, 0.001931072732585, 0.001831586798359, 0.001735427711423,
     0.001642587753007, 0.001553052860930, 0.001466802891491, 0.001383811890755,
     0.001304048374716, 0.001227475616900, 0.001154051942217, 0.001083731025617,
     0.001016462194703, 0.000952190735149, 0.000890858197110, 0.000832402702294,
     0.000776759250136, 0.000723860022294, 0.000673634683977, 0.000626010681838,
     0.000580913536707, 0.000538267130868, 0.000497993989069, 0.000460015551653,
     0.000424252440518, 0.000390624715628, 0.000359052122812, 0.000329454331625,
     0.000301751162750, 0.000275862804808, 0.000251710020027, 0.000229214338496,
     0.000208298240660, 0.000188885328279, 0.000170900482798, 0.000154270012137,
     0.000138921785260, 0.000124785354321, 0.000111792065160, 0.000099875155888,
     0.000088969843345, 0.000079013398311, 0.000069945209697, 0.000061706837053,
     0.000054242053050, 0.000047496875380, 0.000041419588684, 0.000035960757034,
     0.000031073227314, 0.000026712124166, 0.000022834836357, 0.000019400995965,
     0.000016372450007, 0.000013713225713, 0.000011389489511, 0.000009369500189,
     0.000007623557621, 0.000006123946040, 0.000004844873785, 0.000003762409463,
     0.000006462031529,
];

/// 329-tap decimation-by-64
const FIR_2048_64: &[f32] = &[
     0.000000000199668, 0.000000205043166, 0.000000156335587, 0.000000215541606,
     0.000000289043906, 0.000000379397653, 0.000000489366234, 0.000000622040059,
     0.000000780862872, 0.000000969659261, 0.000001192663259, 0.000001454547981,
     0.000001760456262, 0.000002116032238, 0.000002527453817, 0.000003001465946,
     0.000003545414625, 0.000004167281561, 0.000004875719359, 0.000005680087172,
     0.000006590486661, 0.000007617798168, 0.000008773716957, 0.000010070789376,
     0.000011522448815, 0.000013143051261, 0.000014947910332, 0.000016953331574,
     0.000019176645863, 0.000021636241718, 0.000024351596326, 0.000027343305093,
     0.000030633109489, 0.000034243923000, 0.000038199854973, 0.000042526232102,
     0.000047249617395, 0.000052397826336, 0.000057999940064, 0.000064086315335,
     0.000070688591034, 0.000077839691045, 0.000085573823231, 0.000093926474339,
     0.000102934400627, 0.000112635613980, 0.000123069363379, 0.000134276111489,
     0.000146297506226, 0.000159176347141, 0.000172956546458, 0.000187683084638,
     0.000203401960366, 0.000220160134836, 0.000238005470250, 0.000256986662475,
     0.000277153167800, 0.000298555123757, 0.000321243264012, 0.000345268827318,
     0.000370683460586, 0.000397539116108, 0.000425887943051, 0.000455782173269,
     0.000487274001624, 0.000520415460934, 0.000555258291741, 0.000591853807104,
     0.000630252752645, 0.000670505162114, 0.000712660208750, 0.000756766052737,
     0.000802869685119, 0.000851016768484, 0.000901251474847, 0.000953616321094,
     0.001008152002452, 0.001064897224391, 0.001123888533469, 0.001185160147570,
     0.001248743786063, 0.001314668500389, 0.001382960505628, 0.001453643013568,
     0.001526736067868, 0.001602256381861, 0.001680217179590, 0.001760628040646,
     0.001843494749418, 0.001928819149316, 0.002016599002583, 0.002106827856267,
     0.002199494914939, 0.002294584920730, 0.002392078041256, 0.002491949765985,
     0.002594170811576, 0.002698707036722, 0.002805519367007, 0.002914563730244,
     0.003025791002763, 0.003139146967090, 0.003254572281416, 0.003372002461236,
     0.003491367873501, 0.003612593743601, 0.003735600175462, 0.003860302184972,
     0.003986609746975, 0.004114427855956, 0.004243656600570, 0.004374191252069,
     0.004505922366671, 0.004638735901866, 0.004772513346579, 0.004907131865119,
     0.005042464454740, 0.005178380116639, 0.005314744040122, 0.005451417799686,
     0.005588259564642, 0.005725124320935, 0.005861864104709, 0.005998328247162,
     0.006134363630171, 0.006269814952126, 0.006404525003407, 0.006538334950818,
     0.006671084630359, 0.006802612847587, 0.006932757684861, 0.007061356814659,
     0.007188247818209, 0.007313268508566, 0.007436257257322, 0.007557053324043,
     0.007675497187571, 0.007791430878266, 0.007904698310281, 0.008015145612939,
     0.008122621460286, 0.008226977397872, 0.008328068165838, 0.008425752017374,
     0.008519891031616, 0.008610351420080, 0.008697003825729, 0.008779723613781,
     0.008858391153404, 0.008932892089457, 0.009003117603448, 0.009068964662954,
     0.009130336258703, 0.009187141628648, 0.009239296468318, 0.009286723126810,
     0.009329350787828, 0.009367115635223, 0.009399961002488, 0.009427837505799,
     0.009450703160140, 0.009468523478197, 0.009481271551679, 0.009488928114839,
     0.009491481589983, 0.009488928114839, 0.009481271551679, 0.009468523478197,
     0.009450703160140, 0.009427837505799, 0.009399961002488, 0.009367115635223,
     0.009329350787828, 0.009286723126810, 0.009239296468318, 0.009187141628648,
     0.009130336258703, 0.009068964662954, 0.009003117603448, 0.008932892089457,
     0.008858391153404, 0.008779723613781, 0.008697003825729, 0.008610351420080,
     0.008519891031616, 0.008425752017374, 0.008328068165838, 0.008226977397872,
     0.008122621460286, 0.008015145612939, 0.007904698310281, 0.007791430878266,
     0.007675497187571, 0.007557053324043, 0.007436257257322, 0.007313268508566,
     0.007188247818209, 0.007061356814659, 0.006932757684861, 0.006802612847587,
     0.006671084630359, 0.006538334950818, 0.006404525003407, 0.006269814952126,
     0.006134363630171, 0.005998328247162, 0.005861864104709, 0.005725124320935,
     0.005588259564642, 0.005451417799686, 0.005314744040122, 0.005178380116639,
     0.005042464454740, 0.004907131865119, 0.004772513346579, 0.004638735901866,
     0.004505922366671, 0.004374191252069, 0.004243656600570, 0.004114427855956,
     0.003986609746975, 0.003860302184972, 0.003735600175462, 0.003612593743601,
     0.003491367873501, 0.003372002461236, 0.003254572281416, 0.003139146967090,
     0.003025791002763, 0.002914563730244, 0.002805519367007, 0.002698707036722,
     0.002594170811576, 0.002491949765985, 0.002392078041256, 0.002294584920730,
     0.002199494914939, 0.002106827856267, 0.002016599002583, 0.001928819149316,
     0.001843494749418, 0.001760628040646, 0.001680217179590, 0.001602256381861,
     0.001526736067868, 0.001453643013568, 0.001382960505628, 0.001314668500389,
     0.001248743786063, 0.001185160147570, 0.001123888533469, 0.001064897224391,
     0.001008152002452, 0.000953616321094, 0.000901251474847, 0.000851016768484,
     0.000802869685119, 0.000756766052737, 0.000712660208750, 0.000670505162114,
     0.000630252752645, 0.000591853807104, 0.000555258291741, 0.000520415460934,
     0.000487274001624, 0.000455782173269, 0.000425887943051, 0.000397539116108,
     0.000370683460586, 0.000345268827318, 0.000321243264012, 0.000298555123757,
     0.000277153167800, 0.000256986662475, 0.000238005470250, 0.000220160134836,
     0.000203401960366, 0.000187683084638, 0.000172956546458, 0.000159176347141,
     0.000146297506226, 0.000134276111489, 0.000123069363379, 0.000112635613980,
     0.000102934400627, 0.000093926474339, 0.000085573823231, 0.000077839691045,
     0.000070688591034, 0.000064086315335, 0.000057999940064, 0.000052397826336,
     0.000047249617395, 0.000042526232102, 0.000038199854973, 0.000034243923000,
     0.000030633109489, 0.000027343305093, 0.000024351596326, 0.000021636241718,
     0.000019176645863, 0.000016953331574, 0.000014947910332, 0.000013143051261,
     0.000011522448815, 0.000010070789376, 0.000008773716957, 0.000007617798168,
     0.000006590486661, 0.000005680087172, 0.000004875719359, 0.000004167281561,
     0.000003545414625, 0.000003001465946, 0.000002527453817, 0.000002116032238,
     0.000001760456262, 0.000001454547981, 0.000001192663259, 0.000000969659261,
     0.000000780862872, 0.000000622040059, 0.000000489366234, 0.000000379397653,
     0.000000289043906, 0.000000215541606, 0.000000156335587, 0.000000205043166,
     0.000000000199668,
];

/// 400-tap decimation-by-64
const FIR_4096_64: &[f32] = &[
    -0.000000046390182,-0.000000032671747,-0.000000044019252,-0.000000057847980,
    -0.000000074525736,-0.000000094444277,-0.000000118038962,-0.000000145771056,
    -0.000000178146920,-0.000000215699912,-0.000000259008968,-0.000000308679966,
    -0.000000365363532,-0.000000429735743,-0.000000502514971,-0.000000584441775,
    -0.000000676294593,-0.000000778868675,-0.000000892990408,-0.000001019495135,
    -0.000001159239908,-0.000001313080019,-0.000001481879981,-0.000001666488590,
    -0.000001867747936,-0.000002086466837,-0.000002323427660,-0.000002579357987,
    -0.000002854935059,-0.000003150755519,-0.000003467337309,-0.000003805087370,
    -0.000004164300851,-0.000004545126650,-0.000004947563816,-0.000005371424879,
    -0.000005816329343,-0.000006281664776,-0.000006766577359,-0.000007269930729,
    -0.000007790293600,-0.000008325896421,-0.000008874616111,-0.000009433930650,
    -0.000010000901045,-0.000010572124028,-0.000011143711423,-0.000011711241185,
    -0.000012269734415,-0.000012813605044,-0.000013336634806,-0.000013831921934,
    -0.000014291854483,-0.000014708058478,-0.000015071370042,-0.000015371783506,
    -0.000015598422879,-0.000015739490502,-0.000015782238450,-0.000015712918389,
    -0.000015516753573,-0.000015177890614,-0.000014679372808,-0.000014003094579,
    -0.000013129776918,-0.000012038925327,-0.000010708808188,-0.000009116419073,
    -0.000007237458911,-0.000005046303536,-0.000002515990559, 0.000000381806950,
     0.000003676787983, 0.000007400042869, 0.000011584054294, 0.000016262708632,
     0.000021471289584, 0.000027246480702, 0.000033626350795, 0.000040650346831,
     0.000048359270314, 0.000056795259795, 0.000066001757509, 0.000076023480814,
     0.000086906378438, 0.000098697590282, 0.000111445392736, 0.000125199146376,
     0.000140009229952, 0.000155926975644, 0.000173004591440, 0.000191295083774,
     0.000210852168180, 0.000231730179287, 0.000253983969797, 0.000277668807996,
     0.000302840265281, 0.000329554101525, 0.000357866141575, 0.000387832149003,
     0.000419507692185, 0.000452948007177, 0.000488207854178, 0.000525341370472,
     0.000564401918290, 0.000605441928944, 0.000648512743304, 0.000693664448459,
     0.000740945712207, 0.000790403613766, 0.000842083473864, 0.000896028681201,
     0.000952280519889, 0.001010877993535, 0.001071857651943, 0.001135253414817,
     0.001201096399779, 0.001269414747828, 0.001340233454817, 0.001413574200910,
     0.001489455187766, 0.001567890974290, 0.001648892321822, 0.001732466038541,
     0.001818614834973, 0.001907337179413, 0.001998627166072, 0.002092474383846,
     0.002188863799386, 0.002287775641494, 0.002389185301308, 0.002493063234514,
     0.002599374880741, 0.002708080585641, 0.002819135541432, 0.002932489730741,
     0.003048087890061, 0.003165869477045, 0.003285768658416, 0.003407714302186,
     0.003531629991321, 0.003657434042076, 0.003785039544443, 0.003914354407524,
     0.004045281427483, 0.004177718360558, 0.004311558018921, 0.004446688371607,
     0.004582992668347, 0.004720349568330, 0.004858633291726, 0.004997713775860,
     0.005137456853766, 0.005277724436980, 0.005418374720123, 0.005559262389150,
     0.005700238850592, 0.005841152463751, 0.005981848792879, 0.006122170861453,
     0.006261959425236, 0.006401053246440, 0.006539289385285, 0.006676503491561,
     0.006812530112001, 0.006947202996460, 0.007080355418172, 0.007211820491505,
     0.007341431501933, 0.007469022232125, 0.007594427298261, 0.007717482481038,
     0.007838025064813, 0.007955894169977, 0.008070931091297, 0.008182979628023,
     0.008291886417752, 0.008397501260587, 0.008499677444830, 0.008598272061538,
     0.008693146318384, 0.008784165841015, 0.008871200971516, 0.008954127053079,
     0.009032824709643, 0.009107180110554, 0.009177085228136, 0.009242438079217,
     0.009303142957628, 0.009359110649733, 0.009410258639107, 0.009456511293501,
     0.009497800039280, 0.009534063517579, 0.009565247726420, 0.009591306144175,
     0.009612199837674, 0.009627897551475, 0.009638375780671, 0.009643618824881,
     0.009643618824881, 0.009638375780671, 0.009627897551475, 0.009612199837674,
     0.009591306144175, 0.009565247726420, 0.009534063517579, 0.009497800039280,
     0.009456511293501, 0.009410258639107, 0.009359110649733, 0.009303142957628,
     0.009242438079217, 0.009177085228136, 0.009107180110554, 0.009032824709643,
     0.008954127053079, 0.008871200971516, 0.008784165841015, 0.008693146318384,
     0.008598272061538, 0.008499677444830, 0.008397501260587, 0.008291886417752,
     0.008182979628023, 0.008070931091297, 0.007955894169977, 0.007838025064813,
     0.007717482481038, 0.007594427298261, 0.007469022232125, 0.007341431501933,
     0.007211820491505, 0.007080355418172, 0.006947202996460, 0.006812530112001,
     0.006676503491561, 0.006539289385285, 0.006401053246440, 0.006261959425236,
     0.006122170861453, 0.005981848792879, 0.005841152463751, 0.005700238850592,
     0.005559262389150, 0.005418374720123, 0.005277724436980, 0.005137456853766,
     0.004997713775860, 0.004858633291726, 0.004720349568330, 0.004582992668347,
     0.004446688371607, 0.004311558018921, 0.004177718360558, 0.004045281427483,
     0.003914354407524, 0.003785039544443, 0.003657434042076, 0.003531629991321,
     0.003407714302186, 0.003285768658416, 0.003165869477045, 0.003048087890061,
     0.002932489730741, 0.002819135541432, 0.002708080585641, 0.002599374880741,
     0.002493063234514, 0.002389185301308, 0.002287775641494, 0.002188863799386,
     0.002092474383846, 0.001998627166072, 0.001907337179413, 0.001818614834973,
     0.001732466038541, 0.001648892321822, 0.001567890974290, 0.001489455187766,
     0.001413574200910, 0.001340233454817, 0.001269414747828, 0.001201096399779,
     0.001135253414817, 0.001071857651943, 0.001010877993535, 0.000952280519889,
     0.000896028681201, 0.000842083473864, 0.000790403613766, 0.000740945712207,
     0.000693664448459, 0.000648512743304, 0.000605441928944, 0.000564401918290,
     0.000525341370472, 0.000488207854178, 0.000452948007177, 0.000419507692185,
     0.000387832149003, 0.000357866141575, 0.000329554101525, 0.000302840265281,
     0.000277668807996, 0.000253983969797, 0.000231730179287, 0.000210852168180,
     0.000191295083774, 0.000173004591440, 0.000155926975644, 0.000140009229952,
     0.000125199146376, 0.000111445392736, 0.000098697590282, 0.000086906378438,
     0.000076023480814, 0.000066001757509, 0.000056795259795, 0.000048359270314,
     0.000040650346831, 0.000033626350795, 0.000027246480702, 0.000021471289584,
     0.000016262708632, 0.000011584054294, 0.000007400042869, 0.000003676787983,
     0.000000381806950,-0.000002515990559,-0.000005046303536,-0.000007237458911,
    -0.000009116419073,-0.000010708808188,-0.000012038925327,-0.000013129776918,
    -0.000014003094579,-0.000014679372808,-0.000015177890614,-0.000015516753573,
    -0.000015712918389,-0.000015782238450,-0.000015739490502,-0.000015598422879,
    -0.000015371783506,-0.000015071370042,-0.000014708058478,-0.000014291854483,
    -0.000013831921934,-0.000013336634806,-0.000012813605044,-0.000012269734415,
    -0.000011711241185,-0.000011143711423,-0.000010572124028,-0.000010000901045,
    -0.000009433930650,-0.000008874616111,-0.000008325896421,-0.000007790293600,
    -0.000007269930729,-0.000006766577359,-0.000006281664776,-0.000005816329343,
    -0.000005371424879,-0.000004947563816,-0.000004545126650,-0.000004164300851,
    -0.000003805087370,-0.000003467337309,-0.000003150755519,-0.000002854935059,
    -0.000002579357987,-0.000002323427660,-0.000002086466837,-0.000001867747936,
    -0.000001666488590,-0.000001481879981,-0.000001313080019,-0.000001159239908,
    -0.000001019495135,-0.000000892990408,-0.000000778868675,-0.000000676294593,
    -0.000000584441775,-0.000000502514971,-0.000000429735743,-0.000000365363532,
    -0.000000308679966,-0.000000259008968,-0.000000215699912,-0.000000178146920,
    -0.000000145771056,-0.000000118038962,-0.000000094444277,-0.000000074525736,
    -0.000000057847980,-0.000000044019252,-0.000000032671747,-0.000000046390182,
];

// ── Decimation plan definitions (matches SDR++ decim/plans.h) ───────────────

struct DecimStage {
    decimation: usize,
    taps: &'static [f32],
}

/// Get the decimation plan for a given power-of-2 ratio.
/// Returns list of (decimation, taps) stages.
fn get_decim_plan(ratio: usize) -> Vec<DecimStage> {
    match ratio {
        1   => vec![],
        2   => vec![ DecimStage { decimation: 2, taps: FIR_2_2 } ],
        4   => vec![ DecimStage { decimation: 2, taps: FIR_4_2 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        8   => vec![ DecimStage { decimation: 4, taps: FIR_8_4 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        16  => vec![ DecimStage { decimation: 8, taps: FIR_16_8 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        32  => vec![ DecimStage { decimation: 8, taps: FIR_32_8 }, DecimStage { decimation: 2, taps: FIR_4_2 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        64  => vec![ DecimStage { decimation: 8, taps: FIR_64_8 }, DecimStage { decimation: 4, taps: FIR_8_4 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        128 => vec![ DecimStage { decimation: 16, taps: FIR_128_16 }, DecimStage { decimation: 4, taps: FIR_8_4 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        256 => vec![ DecimStage { decimation: 32, taps: FIR_256_32 }, DecimStage { decimation: 4, taps: FIR_8_4 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        512 => vec![ DecimStage { decimation: 32, taps: FIR_512_32 }, DecimStage { decimation: 8, taps: FIR_16_8 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        1024 => vec![ DecimStage { decimation: 64, taps: FIR_1024_64 }, DecimStage { decimation: 8, taps: FIR_16_8 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        2048 => vec![ DecimStage { decimation: 64, taps: FIR_2048_64 }, DecimStage { decimation: 8, taps: FIR_32_8 }, DecimStage { decimation: 2, taps: FIR_4_2 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        4096 => vec![ DecimStage { decimation: 64, taps: FIR_4096_64 }, DecimStage { decimation: 8, taps: FIR_64_8 }, DecimStage { decimation: 4, taps: FIR_8_4 }, DecimStage { decimation: 2, taps: FIR_2_2 } ],
        _ => {
            // Fallback: find the largest supported ratio that fits
            let mut r = 1;
            while r * 2 <= ratio && r * 2 <= 4096 {
                r *= 2;
            }
            get_decim_plan(r)
        }
    }
}

// ── ComplexDecimatingFIR (matches SDR++ dsp/filter/decimating_fir.h) ────────

/// Decimating FIR filter for complex IQ data.
/// Applies an FIR filter and keeps only every `decimation`-th output sample.
struct ComplexDecimatingFIR {
    taps: Vec<f32>,
    tap_count: usize,
    decimation: usize,
    buffer_i: Vec<f32>,
    buffer_q: Vec<f32>,
    offset: usize,
}

impl ComplexDecimatingFIR {
    fn new(taps: &[f32], decimation: usize) -> Self {
        let tap_count = taps.len();
        let buf_size = tap_count - 1 + 262144;
        let mut buffer_i = vec![0.0f32; buf_size];
        let mut buffer_q = vec![0.0f32; buf_size];
        // Zero the history portion
        for i in 0..tap_count - 1 {
            buffer_i[i] = 0.0;
            buffer_q[i] = 0.0;
        }
        ComplexDecimatingFIR {
            taps: taps.to_vec(),
            tap_count,
            decimation,
            buffer_i,
            buffer_q,
            offset: 0,
        }
    }

    /// Process `count` complex IQ samples. Input is in `in_i`/`in_q` slices.
    /// Output is written to `out_i`/`out_q` starting at index 0.
    /// Returns the number of output samples produced.
    fn process(&mut self, count: usize, in_i: &[f32], in_q: &[f32],
               out_i: &mut [f32], out_q: &mut [f32]) -> usize {
        let hist = self.tap_count - 1;
        let needed = hist + count;
        if needed > self.buffer_i.len() {
            self.buffer_i.resize(needed, 0.0);
            self.buffer_q.resize(needed, 0.0);
        }

        // Copy input after history (matches SDR++ memcpy(bufStart, in, count * sizeof(D)))
        self.buffer_i[hist..hist + count].copy_from_slice(&in_i[..count]);
        self.buffer_q[hist..hist + count].copy_from_slice(&in_q[..count]);

        // Convolution at decimated positions
        // (matches SDR++ volk_32fc_32f_dot_prod_32fc at offset positions)
        let mut out_count = 0;
        while self.offset < count {
            let mut sum_i = 0.0f32;
            let mut sum_q = 0.0f32;
            for j in 0..self.tap_count {
                sum_i += self.buffer_i[self.offset + j] * self.taps[j];
                sum_q += self.buffer_q[self.offset + j] * self.taps[j];
            }
            out_i[out_count] = sum_i;
            out_q[out_count] = sum_q;
            out_count += 1;
            self.offset += self.decimation;
        }
        self.offset -= count;

        // Move history (matches SDR++ memmove)
        self.buffer_i.copy_within(count..count + hist, 0);
        self.buffer_q.copy_within(count..count + hist, 0);

        out_count
    }

    fn reset(&mut self) {
        self.buffer_i.fill(0.0);
        self.buffer_q.fill(0.0);
        self.offset = 0;
    }
}

// ── PowerDecimator (matches SDR++ dsp/multirate/power_decimator.h) ──────────

/// Multi-stage power-of-2 decimator using optimized FIR filter plans.
/// Replaces the naive CIC averaging approach with proper anti-aliasing filters
/// matching the SDR++ PowerDecimator implementation.
struct PowerDecimator {
    stages: Vec<ComplexDecimatingFIR>,
    ratio: usize,
    // Ping-pong scratch buffers for multi-stage processing
    buf_a_i: Vec<f32>,
    buf_a_q: Vec<f32>,
    buf_b_i: Vec<f32>,
    buf_b_q: Vec<f32>,
    result_in_a: bool,
}

impl PowerDecimator {
    fn new(ratio: usize) -> Self {
        let actual_ratio = if ratio <= 1 { 1 } else {
            // Clamp to max supported ratio (4096)
            let r = ratio.min(4096);
            // Round down to nearest power of 2
            1usize << (usize::BITS - 1 - r.leading_zeros() as u32)
        };

        let plan = get_decim_plan(actual_ratio);
        let stages: Vec<ComplexDecimatingFIR> = plan.iter()
            .map(|s| ComplexDecimatingFIR::new(s.taps, s.decimation))
            .collect();

        let buf_size = 262144;
        PowerDecimator {
            stages,
            ratio: actual_ratio,
            buf_a_i: vec![0.0; buf_size],
            buf_a_q: vec![0.0; buf_size],
            buf_b_i: vec![0.0; buf_size],
            buf_b_q: vec![0.0; buf_size],
            result_in_a: true,
        }
    }

    /// Process `count` complex samples through all decimation stages.
    /// Input is read from `in_i`/`in_q`.
    /// Output is stored in internal buffers accessible via `output_i()`/`output_q()`.
    /// Returns the number of output samples.
    fn process(&mut self, count: usize, in_i: &[f32], in_q: &[f32]) -> usize {
        if self.stages.is_empty() {
            // ratio == 1: just copy
            if self.buf_a_i.len() < count {
                self.buf_a_i.resize(count, 0.0);
                self.buf_a_q.resize(count, 0.0);
            }
            self.buf_a_i[..count].copy_from_slice(&in_i[..count]);
            self.buf_a_q[..count].copy_from_slice(&in_q[..count]);
            self.result_in_a = true;
            return count;
        }

        // Destructure to allow independent field borrows
        let PowerDecimator {
            stages, buf_a_i, buf_a_q, buf_b_i, buf_b_q, result_in_a, ..
        } = self;

        let stage_count = stages.len();
        let mut cur_count = count;
        let mut in_a = false;

        for i in 0..stage_count {
            if i == 0 {
                // First stage: input → buf_a
                if buf_a_i.len() < cur_count {
                    buf_a_i.resize(cur_count, 0.0);
                    buf_a_q.resize(cur_count, 0.0);
                }
                cur_count = stages[i].process(
                    cur_count, in_i, in_q, buf_a_i, buf_a_q
                );
                in_a = true;
            } else if in_a {
                // buf_a → buf_b
                if buf_b_i.len() < cur_count {
                    buf_b_i.resize(cur_count, 0.0);
                    buf_b_q.resize(cur_count, 0.0);
                }
                cur_count = stages[i].process(
                    cur_count, buf_a_i, buf_a_q, buf_b_i, buf_b_q
                );
                in_a = false;
            } else {
                // buf_b → buf_a
                if buf_a_i.len() < cur_count {
                    buf_a_i.resize(cur_count, 0.0);
                    buf_a_q.resize(cur_count, 0.0);
                }
                cur_count = stages[i].process(
                    cur_count, buf_b_i, buf_b_q, buf_a_i, buf_a_q
                );
                in_a = true;
            }
        }

        *result_in_a = in_a;
        cur_count
    }

    fn output_i(&self) -> &[f32] {
        if self.result_in_a { &self.buf_a_i } else { &self.buf_b_i }
    }

    fn output_q(&self) -> &[f32] {
        if self.result_in_a { &self.buf_a_q } else { &self.buf_b_q }
    }

    fn reset(&mut self) {
        for stage in &mut self.stages {
            stage.reset();
        }
    }
}

/// Compute the power-of-2 decimation ratio for a given sample rate conversion.
/// Matches SDR++ RationalResampler's PowerDecimator ratio selection:
/// ratio = 2^floor(log2(inSR / outSR)), clamped to [1, 4096]
fn compute_power_decim_ratio(in_sr: f32, out_sr: f32) -> usize {
    let ratio = in_sr / out_sr;
    if ratio < 2.0 {
        return 1;
    }
    let power = (ratio.log2().floor() as u32).min(12); // max 2^12 = 4096
    1usize << power
}

/// Split a power-of-2 decimation ratio into CIC stages and FIR ratio.
///
/// Previous approach used CIC (pair-averaging) for bulk decimation, but
/// CIC has very poor anti-aliasing: a single CIC-by-2 stage provides only
/// ~-1.8 dB rejection at 0.8×fs, letting broadband noise alias into the
/// passband. At 20 MHz with 5 CIC stages, this caused clearly audible noise.
///
/// Now the PowerDecimator handles ALL decimation using SDR++ FIR filter plans
/// (get_decim_plan) which provide proper >60 dB stopband rejection.
/// At 20 MHz (ratio=64), the 3-stage FIR plan costs ~1.7M multiply-adds
/// (~2-3ms in WASM), well within the 6.5ms USB callback budget.
///
/// Returns (cic_stages=0, fir_ratio=total_ratio).
fn split_decim_ratio(total_ratio: usize) -> (usize, usize) {
    // No CIC stages — PowerDecimator handles all decimation with proper
    // anti-aliasing FIR filters matching SDR++ power_decimator.h
    (0, total_ratio)
}

// ============================================================================
// Polyphase Rational Resampler (matches SDR++ dsp/multirate/polyphase_resampler.h)
// ============================================================================

/// Polyphase rational resampler for f32 mono audio data.
/// Resamples by interp/decim ratio using a polyphase filter bank.
struct PolyphaseResamplerF32 {
    interp: usize,
    decim: usize,
    taps_per_phase: usize,
    phases: Vec<Vec<f32>>,
    buffer: Vec<f32>,
    buf_start_offset: usize,
    phase: usize,
    offset: usize,
}

impl PolyphaseResamplerF32 {
    fn new(interp: usize, decim: usize, taps: &[f32]) -> Self {
        let phase_count = interp;
        let taps_per_phase = (taps.len() + phase_count - 1) / phase_count;
        let mut phases = vec![vec![0.0f32; taps_per_phase]; phase_count];

        let tot_tap_count = phase_count * taps_per_phase;
        for i in 0..tot_tap_count {
            let phase_idx = (phase_count - 1) - (i % phase_count);
            let tap_idx = i / phase_count;
            phases[phase_idx][tap_idx] = if i < taps.len() { taps[i] } else { 0.0 };
        }

        let buffer = vec![0.0f32; taps_per_phase - 1 + 65536];
        PolyphaseResamplerF32 {
            interp,
            decim,
            taps_per_phase,
            phases,
            buffer,
            buf_start_offset: taps_per_phase - 1,
            phase: 0,
            offset: 0,
        }
    }

    fn process(&mut self, input: &[f32], output: &mut Vec<f32>) {
        let count = input.len();
        // Grow buffer dynamically if input exceeds pre-allocated size
        let needed = self.buf_start_offset + count;
        if needed > self.buffer.len() {
            self.buffer.resize(needed, 0.0);
        }
        // Copy input into delay line
        self.buffer[self.buf_start_offset..self.buf_start_offset + count]
            .copy_from_slice(input);

        while self.offset < count {
            // Dot product with current phase taps
            let phase_taps = &self.phases[self.phase];
            let mut sum = 0.0f32;
            for j in 0..self.taps_per_phase {
                sum += self.buffer[self.offset + j] * phase_taps[j];
            }
            output.push(sum);

            self.phase += self.decim;
            self.offset += self.phase / self.interp;
            self.phase %= self.interp;
        }
        self.offset -= count;

        // Move delay line (memmove equivalent)
        self.buffer.copy_within(count..count + self.taps_per_phase - 1, 0);
    }

    fn reset(&mut self) {
        self.buffer.fill(0.0);
        self.phase = 0;
        self.offset = 0;
    }
}

/// Polyphase rational resampler for complex IQ data.
/// Each complex sample is two f32 (I, Q) interleaved.
struct PolyphaseResamplerComplex {
    interp: usize,
    decim: usize,
    taps_per_phase: usize,
    phases: Vec<Vec<f32>>,
    // Buffer stores Complex<f32> but we work with raw pairs for wasm compat
    buffer_i: Vec<f32>,
    buffer_q: Vec<f32>,
    buf_start_offset: usize,
    phase: usize,
    offset: usize,
}

impl PolyphaseResamplerComplex {
    fn new(interp: usize, decim: usize, taps: &[f32]) -> Self {
        let phase_count = interp;
        let taps_per_phase = (taps.len() + phase_count - 1) / phase_count;
        let mut phases = vec![vec![0.0f32; taps_per_phase]; phase_count];

        let tot_tap_count = phase_count * taps_per_phase;
        for i in 0..tot_tap_count {
            let phase_idx = (phase_count - 1) - (i % phase_count);
            let tap_idx = i / phase_count;
            phases[phase_idx][tap_idx] = if i < taps.len() { taps[i] } else { 0.0 };
        }

        let buf_size = taps_per_phase - 1 + 262144;
        PolyphaseResamplerComplex {
            interp,
            decim,
            taps_per_phase,
            phases,
            buffer_i: vec![0.0f32; buf_size],
            buffer_q: vec![0.0f32; buf_size],
            buf_start_offset: taps_per_phase - 1,
            phase: 0,
            offset: 0,
        }
    }

    /// Process `count` complex samples from separate I/Q arrays.
    /// Output is appended to out_i and out_q.
    fn process(&mut self, in_i: &[f32], in_q: &[f32], out_i: &mut Vec<f32>, out_q: &mut Vec<f32>) {
        let count = in_i.len();
        debug_assert_eq!(in_i.len(), in_q.len());

        // Grow buffers dynamically if input exceeds pre-allocated size
        let needed = self.buf_start_offset + count;
        if needed > self.buffer_i.len() {
            self.buffer_i.resize(needed, 0.0);
            self.buffer_q.resize(needed, 0.0);
        }

        self.buffer_i[self.buf_start_offset..self.buf_start_offset + count]
            .copy_from_slice(in_i);
        self.buffer_q[self.buf_start_offset..self.buf_start_offset + count]
            .copy_from_slice(in_q);

        while self.offset < count {
            let phase_taps = &self.phases[self.phase];
            let mut sum_i = 0.0f32;
            let mut sum_q = 0.0f32;
            for j in 0..self.taps_per_phase {
                sum_i += self.buffer_i[self.offset + j] * phase_taps[j];
                sum_q += self.buffer_q[self.offset + j] * phase_taps[j];
            }
            out_i.push(sum_i);
            out_q.push(sum_q);

            self.phase += self.decim;
            self.offset += self.phase / self.interp;
            self.phase %= self.interp;
        }
        self.offset -= count;

        self.buffer_i.copy_within(count..count + self.taps_per_phase - 1, 0);
        self.buffer_q.copy_within(count..count + self.taps_per_phase - 1, 0);
    }

    fn reset(&mut self) {
        self.buffer_i.fill(0.0);
        self.buffer_q.fill(0.0);
        self.phase = 0;
        self.offset = 0;
    }
}

// ============================================================================
// FIR Filter (matches SDR++ dsp/filter/fir.h)
// ============================================================================

/// Complex FIR filter with real taps (matches SDR++ volk_32fc_32f_dot_prod_32fc)
struct ComplexFIR {
    taps: Vec<f32>,
    history_i: Vec<f32>,
    history_q: Vec<f32>,
    hist_idx: usize,
}

impl ComplexFIR {
    fn new(taps: Vec<f32>) -> Self {
        let len = taps.len();
        ComplexFIR {
            taps,
            history_i: vec![0.0; len],
            history_q: vec![0.0; len],
            hist_idx: 0,
        }
    }

    fn set_taps(&mut self, taps: Vec<f32>) {
        let len = taps.len();
        self.taps = taps;
        self.history_i = vec![0.0; len];
        self.history_q = vec![0.0; len];
        self.hist_idx = 0;
    }

    fn process_block(&mut self, in_i: &[f32], in_q: &[f32], out_i: &mut [f32], out_q: &mut [f32]) {
        for k in 0..in_i.len() {
            self.history_i[self.hist_idx] = in_i[k];
            self.history_q[self.hist_idx] = in_q[k];

            let mut si = 0.0f32;
            let mut sq = 0.0f32;
            let mut tap_idx = 0;

            // Circular buffer dot product
            let mut i = self.hist_idx as isize;
            loop {
                si += self.history_i[i as usize] * self.taps[tap_idx];
                sq += self.history_q[i as usize] * self.taps[tap_idx];
                tap_idx += 1;
                i -= 1;
                if i < 0 { i = self.taps.len() as isize - 1; }
                if i == self.hist_idx as isize { break; }
            }

            out_i[k] = si;
            out_q[k] = sq;

            self.hist_idx += 1;
            if self.hist_idx >= self.taps.len() {
                self.hist_idx = 0;
            }
        }
    }

    fn reset(&mut self) {
        self.history_i.fill(0.0);
        self.history_q.fill(0.0);
        self.hist_idx = 0;
    }
}

/// Real FIR filter with real taps (for post-demod audio filtering)
struct RealFIR {
    taps: Vec<f32>,
    history: Vec<f32>,
    hist_idx: usize,
}

impl RealFIR {
    fn new(taps: Vec<f32>) -> Self {
        let len = taps.len();
        RealFIR {
            taps,
            history: vec![0.0; len],
            hist_idx: 0,
        }
    }

    fn set_taps(&mut self, taps: Vec<f32>) {
        let len = taps.len();
        self.taps = taps;
        self.history = vec![0.0; len];
        self.hist_idx = 0;
    }

    fn process_block(&mut self, input: &[f32], output: &mut [f32]) {
        for k in 0..input.len() {
            self.history[self.hist_idx] = input[k];

            let mut sum = 0.0f32;
            let mut tap_idx = 0;

            let mut i = self.hist_idx as isize;
            loop {
                sum += self.history[i as usize] * self.taps[tap_idx];
                tap_idx += 1;
                i -= 1;
                if i < 0 { i = self.taps.len() as isize - 1; }
                if i == self.hist_idx as isize { break; }
            }

            output[k] = sum;

            self.hist_idx += 1;
            if self.hist_idx >= self.taps.len() {
                self.hist_idx = 0;
            }
        }
    }

    fn reset(&mut self) {
        self.history.fill(0.0);
        self.hist_idx = 0;
    }
}

// ============================================================================
// DspProcessor — Full SDR++ VFO + Demod Pipeline
// ============================================================================
//
// Signal chain (matches SDR++ exactly):
//   1. FrequencyXlator (NCO mixer) — complex rotate to shift channel to baseband
//   2. RationalResampler (polyphase) — decimate from source SR → IF SR (50 kHz)
//   3. Channel FIR filter — LPF at bandwidth/2 (only if bandwidth != IF SR)
//   4. Squelch — avg magnitude gate on complex IQ (pre-demod)
//   5. Quadrature FM discriminator — atan2 phase diff → float audio
//   6. Post-demod FIR filter — LPF at bandwidth/2 on demodulated audio
//   7. Audio RationalResampler — 50 kHz → 48 kHz (polyphase)
//
// All steps run at appropriate sample rates, matching SDR++ processing order.

#[wasm_bindgen]
pub struct DspProcessor {
    // NCO state (phasor form — no per-sample trig, just complex multiply)
    phasor_re: f32,
    phasor_im: f32,
    phasor_inc_re: f32,
    phasor_inc_im: f32,

    // Sample rates
    in_sample_rate: f32,
    if_sample_rate: f32,   // 50000.0 Hz (matches SDR++ NFM getIFSampleRate)
    audio_sample_rate: f32, // 48000.0 Hz

    // Pre-decimation: hybrid CIC + FIR approach for efficiency
    // CIC averaging handles bulk decimation (essentially free in-place ops).
    // A single FIR_2_2 stage provides proper anti-aliasing at the final stage
    // where sample count is low enough for FIR to be affordable.
    cic_stages: usize,
    power_decim: PowerDecimator,

    // WFM mode flag (uses SDR++ broadcast_fm.h audio filter settings)
    is_wfm: bool,

    // Bandwidth
    bandwidth: f32,

    // IQ resampler: pre_decim_rate → 50 kHz
    iq_resampler: PolyphaseResamplerComplex,

    // Channel bandwidth FIR filter (complex, operates at IF SR)
    channel_filter: ComplexFIR,
    channel_filter_needed: bool,

    // FM demodulator state
    prev_phase: f32,
    inv_deviation: f32,

    // Post-demod FIR (real, operates at IF SR)
    post_demod_fir: RealFIR,

    // Audio resampler: IF SR → audio SR
    audio_resampler: PolyphaseResamplerF32,

    // Squelch state
    squelch_level: f32,   // dB threshold (-100 = disabled)
    squelch_enabled: bool,

    // DC Blocker state (matches SDR++ dc_block.h)
    dc_avg_i: f32,
    dc_avg_q: f32,
    dc_alpha: f32,

    // NCO output buffers (reused to avoid per-call allocation)
    nco_buf_i: Vec<f32>,
    nco_buf_q: Vec<f32>,

    // Scratch buffers (reused to avoid allocations)
    scratch_i: Vec<f32>,
    scratch_q: Vec<f32>,
    scratch_i2: Vec<f32>,
    scratch_q2: Vec<f32>,
    scratch_audio: Vec<f32>,
    scratch_audio2: Vec<f32>,
}

#[wasm_bindgen]
impl DspProcessor {
    /// Create a new DSP processor matching SDR++ NFM pipeline.
    ///
    /// # Arguments
    /// * `in_sample_rate` - Source sample rate (e.g. 2_000_000.0 for 2 MHz)
    /// * `shift_hz` - Frequency offset in Hz (VFO offset from center)
    /// * `bandwidth` - Channel bandwidth in Hz (default 12500.0 for NFM)
    #[wasm_bindgen(constructor)]
    pub fn new(in_sample_rate: f32, shift_hz: f32, bandwidth: f32) -> Self {
        let if_sample_rate = 50000.0f32;
        let audio_sample_rate = 48000.0f32;

        // NCO: phasor form (negate offset to match SDR++ xlator.init(NULL, -_offset, _inSR))
        let phase_inc = -2.0 * PI * shift_hz / in_sample_rate;
        let (sin_inc, cos_inc) = phase_inc.sin_cos();

        // Pre-decimation: hybrid CIC + FIR
        // CIC averaging handles bulk decimation (free, in-place).
        // FIR_2_2 (69-tap) provides final anti-aliasing at reduced rate.
        // At 20 MHz WFM: CIC 32x (131k→4k, ~0.3ms) + FIR 2x (4k→2k, ~0.3ms)
        // vs all-FIR which took ~3ms and exceeded the 6.5ms USB budget.
        let total_ratio = compute_power_decim_ratio(in_sample_rate, if_sample_rate);
        let (cic_stages, fir_ratio) = split_decim_ratio(total_ratio);
        let power_decim = PowerDecimator::new(fir_ratio);
        let pre_decim_rate = in_sample_rate / total_ratio as f32;

        // IQ rational resampler: pre_decim_rate → IF
        let iq_resampler = Self::build_complex_resampler(pre_decim_rate, if_sample_rate);

        // Channel filter: LPF at bandwidth/2, operating at IF SR
        let channel_filter_needed = (bandwidth - if_sample_rate).abs() > 1.0;
        let channel_filter = if channel_filter_needed {
            let filter_width = bandwidth as f64 / 2.0;
            let taps = low_pass_taps(filter_width, filter_width * 0.1, if_sample_rate as f64);
            ComplexFIR::new(taps)
        } else {
            ComplexFIR::new(vec![1.0])
        };

        // FM demodulator: deviation = bandwidth/2
        let deviation_rad = 2.0 * PI * (bandwidth / 2.0) / if_sample_rate;
        let inv_deviation = 1.0 / deviation_rad;

        // Post-demod FIR: LPF at bandwidth/2, transition = 10% of cutoff, at IF SR
        let post_demod_fir = {
            let cutoff = bandwidth as f64 / 2.0;
            let trans = cutoff * 0.1;
            let taps = low_pass_taps(cutoff, trans, if_sample_rate as f64);
            RealFIR::new(taps)
        };

        // Audio resampler: IF SR → audio SR
        let audio_resampler = Self::build_f32_resampler(if_sample_rate, audio_sample_rate);

        let dc_alpha = 1.0 - (10.0 / in_sample_rate);

        DspProcessor {
            phasor_re: 1.0,
            phasor_im: 0.0,
            phasor_inc_re: cos_inc,
            phasor_inc_im: sin_inc,
            in_sample_rate,
            if_sample_rate,
            audio_sample_rate,
            cic_stages,
            power_decim,
            is_wfm: false,
            bandwidth,
            iq_resampler,
            channel_filter,
            channel_filter_needed,
            prev_phase: 0.0,
            inv_deviation,
            post_demod_fir,
            audio_resampler,
            squelch_level: -100.0,
            squelch_enabled: false,
            dc_avg_i: 0.0,
            dc_avg_q: 0.0,
            dc_alpha,
            nco_buf_i: Vec::with_capacity(262144),
            nco_buf_q: Vec::with_capacity(262144),
            scratch_i: Vec::with_capacity(8192),
            scratch_q: Vec::with_capacity(8192),
            scratch_i2: Vec::with_capacity(8192),
            scratch_q2: Vec::with_capacity(8192),
            scratch_audio: Vec::with_capacity(8192),
            scratch_audio2: Vec::with_capacity(8192),
        }
    }

    fn build_complex_resampler(in_sr: f32, out_sr: f32) -> PolyphaseResamplerComplex {
        let in_sr_u = in_sr.round() as usize;
        let out_sr_u = out_sr.round() as usize;
        let d = gcd(in_sr_u, out_sr_u);
        let interp = out_sr_u / d;
        let decim = in_sr_u / d;

        let tap_sr = in_sr as f64 * interp as f64;
        let tap_bw = (in_sr as f64).min(out_sr as f64) / 2.0;
        let tap_tw = tap_bw * 0.1;
        let mut taps = low_pass_taps(tap_bw, tap_tw, tap_sr);
        for t in taps.iter_mut() {
            *t *= interp as f32;
        }

        PolyphaseResamplerComplex::new(interp, decim, &taps)
    }

    fn build_f32_resampler(in_sr: f32, out_sr: f32) -> PolyphaseResamplerF32 {
        let in_sr_u = in_sr.round() as usize;
        let out_sr_u = out_sr.round() as usize;
        let d = gcd(in_sr_u, out_sr_u);
        let interp = out_sr_u / d;
        let decim = in_sr_u / d;

        let tap_sr = in_sr as f64 * interp as f64;
        let tap_bw = (in_sr as f64).min(out_sr as f64) / 2.0;
        let tap_tw = tap_bw * 0.1;
        let mut taps = low_pass_taps(tap_bw, tap_tw, tap_sr);
        for t in taps.iter_mut() {
            *t *= interp as f32;
        }

        PolyphaseResamplerF32::new(interp, decim, &taps)
    }

    /// Update the NCO frequency offset.
    pub fn set_shift(&mut self, sample_rate: f32, shift_hz: f32) {
        self.in_sample_rate = sample_rate;
        self.dc_alpha = 1.0 - (10.0 / sample_rate);
        // Negate offset to match SDR++ FrequencyXlator
        let phase_inc = -2.0 * PI * shift_hz / sample_rate;
        let (sin_inc, cos_inc) = phase_inc.sin_cos();
        self.phasor_inc_re = cos_inc;
        self.phasor_inc_im = sin_inc;
    }

    /// Update the channel bandwidth and rebuild filters.
    pub fn set_bandwidth(&mut self, bandwidth: f32) {
        if (self.bandwidth - bandwidth).abs() < 1.0 {
            return;
        }
        self.bandwidth = bandwidth;

        // Update channel filter
        self.channel_filter_needed = (bandwidth - self.if_sample_rate).abs() > 1.0;
        if self.channel_filter_needed {
            let filter_width = bandwidth as f64 / 2.0;
            let taps = low_pass_taps(filter_width, filter_width * 0.1, self.if_sample_rate as f64);
            self.channel_filter.set_taps(taps);
        }

        // Update FM deviation
        let deviation_rad = 2.0 * PI * (bandwidth / 2.0) / self.if_sample_rate;
        self.inv_deviation = 1.0 / deviation_rad;

        // Update post-demod filter
        // WFM: 15 kHz cutoff, 4 kHz transition (matches SDR++ broadcast_fm.h)
        // NFM/other: bandwidth/2 cutoff, 10% transition
        let (cutoff, trans) = if self.is_wfm {
            (15000.0_f64, 4000.0_f64)
        } else {
            let c = bandwidth as f64 / 2.0;
            (c, c * 0.1)
        };
        let taps = low_pass_taps(cutoff, trans, self.if_sample_rate as f64);
        self.post_demod_fir.set_taps(taps);
    }

    /// Set squelch level in dB. Set to -200 or below to effectively disable.
    pub fn set_squelch(&mut self, level: f32, enabled: bool) {
        self.squelch_level = level;
        self.squelch_enabled = enabled;
    }

    /// Enable or disable WFM mode. When enabled, uses SDR++ broadcast_fm.h
    /// audio filter settings (15 kHz cutoff, 4 kHz transition) instead of
    /// the standard bandwidth/2 cutoff used for NFM and other modes.
    pub fn set_wfm_mode(&mut self, enabled: bool) {
        if self.is_wfm == enabled {
            return;
        }
        self.is_wfm = enabled;
        // Rebuild post-demod filter with appropriate cutoff
        let (cutoff, trans) = if enabled {
            (15000.0_f64, 4000.0_f64)
        } else {
            let c = self.bandwidth as f64 / 2.0;
            (c, c * 0.1)
        };
        let taps = low_pass_taps(cutoff, trans, self.if_sample_rate as f64);
        self.post_demod_fir.set_taps(taps);
    }

    /// Change the IF sample rate and rebuild the entire resampler/filter chain.
    /// SDR++ uses different IF rates per demodulator mode:
    ///   NFM: 50,000 Hz,  WFM: 250,000 Hz,  AM: 15,000 Hz,
    ///   USB/LSB/DSB: 24,000 Hz,  CW: 3,000 Hz
    pub fn set_if_sample_rate(&mut self, new_if_sr: f32) {
        if (self.if_sample_rate - new_if_sr).abs() < 1.0 {
            return;
        }
        self.if_sample_rate = new_if_sr;

        // Rebuild CIC + FIR decimation for new ratio
        let total_ratio = compute_power_decim_ratio(self.in_sample_rate, new_if_sr);
        let (cic_stages, fir_ratio) = split_decim_ratio(total_ratio);
        self.cic_stages = cic_stages;
        self.power_decim = PowerDecimator::new(fir_ratio);
        let pre_decim_rate = self.in_sample_rate / total_ratio as f32;

        // Rebuild IQ resampler: pre_decim_rate → new IF
        self.iq_resampler = Self::build_complex_resampler(pre_decim_rate, new_if_sr);

        // Rebuild channel filter at new IF rate
        self.channel_filter_needed = (self.bandwidth - new_if_sr).abs() > 1.0;
        if self.channel_filter_needed {
            let filter_width = self.bandwidth as f64 / 2.0;
            let taps = low_pass_taps(filter_width, filter_width * 0.1, new_if_sr as f64);
            self.channel_filter.set_taps(taps);
        }

        // Rebuild FM deviation for new IF rate
        let deviation_rad = 2.0 * PI * (self.bandwidth / 2.0) / new_if_sr;
        self.inv_deviation = 1.0 / deviation_rad;

        // Rebuild post-demod filter at new IF rate
        // WFM: 15 kHz cutoff, 4 kHz transition (matches SDR++ broadcast_fm.h)
        let (cutoff, trans) = if self.is_wfm {
            (15000.0_f64, 4000.0_f64)
        } else {
            let c = self.bandwidth as f64 / 2.0;
            (c, c * 0.1)
        };
        let taps = low_pass_taps(cutoff, trans, new_if_sr as f64);
        self.post_demod_fir.set_taps(taps);

        // Rebuild audio resampler: new IF → audio
        self.audio_resampler = Self::build_f32_resampler(new_if_sr, self.audio_sample_rate);

        // Reset all state
        self.prev_phase = 0.0;
        self.phasor_re = 1.0;
        self.phasor_im = 0.0;
        self.channel_filter.reset();
        self.post_demod_fir.reset();
    }

    /// Reset all DSP state (filter histories, demod phase, resampler state).
    /// Call this when switching demodulation modes or when the signal chain
    /// changes to avoid stale state causing audio artifacts.
    pub fn reset(&mut self) {
        // Reset FM demod state
        self.prev_phase = 0.0;

        // Reset NCO phasor (keep frequency, reset phase accumulation)
        self.phasor_re = 1.0;
        self.phasor_im = 0.0;

        // Reset filter histories
        self.channel_filter.reset();
        self.post_demod_fir.reset();

        // Reset decimator
        self.power_decim.reset();

        // Reset resamplers
        self.iq_resampler.reset();
        self.audio_resampler.reset();

        // Reset DC blocker
        self.dc_avg_i = 0.0;
        self.dc_avg_q = 0.0;
    }

    /// Process raw i8 IQ samples through the full SDR++ NFM pipeline.
    /// Returns the number of f32 audio samples written to `output`.
    ///
    /// Input: i8 IQ pairs [I0, Q0, I1, Q1, ...]
    /// Output: f32 mono audio at 48 kHz
    pub fn process(&mut self, input: &[i8], output: &mut [f32]) -> usize {
        let num_iq = input.len() / 2;
        if num_iq == 0 {
            return 0;
        }

        // ── Stage 1: NCO (FrequencyXlator via phasor rotation) ──────
        // Uses complex phasor rotation instead of per-sample sin/cos.
        // Each sample: out = in * phasor; phasor *= phasor_inc
        // Uses indexed writes instead of push() for better WASM perf.
        if self.nco_buf_i.len() < num_iq {
            self.nco_buf_i.resize(num_iq, 0.0);
            self.nco_buf_q.resize(num_iq, 0.0);
        }

        let mut pr = self.phasor_re;
        let mut pi = self.phasor_im;
        let ir = self.phasor_inc_re;
        let ii = self.phasor_inc_im;

        let alpha = self.dc_alpha;
        let mut dc_i = self.dc_avg_i;
        let mut dc_q = self.dc_avg_q;

        for k in 0..num_iq {
            let mut i_val = input[k * 2] as f32 / 128.0;
            let mut q_val = input[k * 2 + 1] as f32 / 128.0;

            // DC Blocker (matches SDR++ genDCBlockRate)
            dc_i = dc_i * alpha + i_val * (1.0 - alpha);
            dc_q = dc_q * alpha + q_val * (1.0 - alpha);
            i_val -= dc_i;
            q_val -= dc_q;

            // Standard complex multiply: (i + jq) * (pr + j*pi)
            //   = (i*pr - q*pi) + j(i*pi + q*pr)
            // Matches SDR++ VOLK volk_32fc_s32fc_x2_rotator2_32fc
            self.nco_buf_i[k] = i_val * pr - q_val * pi;
            self.nco_buf_q[k] = i_val * pi + q_val * pr;

            // Rotate phasor: phasor *= phasor_inc
            let new_r = pr * ir - pi * ii;
            let new_i = pr * ii + pi * ir;
            pr = new_r;
            pi = new_i;
        }

        self.dc_avg_i = dc_i;
        self.dc_avg_q = dc_q;

        // Renormalize phasor to prevent amplitude drift
        let mag = (pr * pr + pi * pi).sqrt();
        self.phasor_re = pr / mag;
        self.phasor_im = pi / mag;

        // ── Stage 1b: CIC pre-decimation (fast in-place averaging) ───
        // Cascaded decimate-by-2 averaging stages to rapidly reduce
        // sample count before FIR. Essentially free (~0.3ms for 5 stages
        // at 20 MHz). Quality is fine at high oversampling ratios.
        let mut cic_len = num_iq;
        for _ in 0..self.cic_stages {
            let half = cic_len / 2;
            for k in 0..half {
                self.nco_buf_i[k] = (self.nco_buf_i[2 * k] + self.nco_buf_i[2 * k + 1]) * 0.5;
                self.nco_buf_q[k] = (self.nco_buf_q[2 * k] + self.nco_buf_q[2 * k + 1]) * 0.5;
            }
            cic_len = half;
        }

        // ── Stage 1c: FIR anti-aliasing (final decimation stage) ─────
        // Single FIR_2_2 (69-tap) provides proper stopband rejection
        // at the reduced sample rate where computation is affordable.
        let decim_len = self.power_decim.process(cic_len, &self.nco_buf_i[..cic_len], &self.nco_buf_q[..cic_len]);

        // ── Stage 2: IQ Rational Resampler (post-decim → IF SR) ─────
        self.scratch_i.clear();
        self.scratch_q.clear();
        self.iq_resampler.process(
            &self.power_decim.output_i()[..decim_len], &self.power_decim.output_q()[..decim_len],
            &mut self.scratch_i, &mut self.scratch_q,
        );
        let if_count = self.scratch_i.len();

        if if_count == 0 {
            return 0;
        }

        // ── Stage 3: Channel Bandwidth FIR Filter ───────────────────
        if self.channel_filter_needed && if_count > 0 {
            self.scratch_i2.resize(if_count, 0.0);
            self.scratch_q2.resize(if_count, 0.0);
            self.channel_filter.process_block(
                &self.scratch_i, &self.scratch_q,
                &mut self.scratch_i2, &mut self.scratch_q2,
            );
            // Swap so scratch_i/q hold filtered output
            std::mem::swap(&mut self.scratch_i, &mut self.scratch_i2);
            std::mem::swap(&mut self.scratch_q, &mut self.scratch_q2);
        }

        // ── Stage 4: Squelch (SDR++ noise_reduction/squelch.h) ──────
        if self.squelch_enabled {
            let mut mag_sum = 0.0f32;
            for k in 0..if_count {
                let i_val = self.scratch_i[k];
                let q_val = self.scratch_q[k];
                mag_sum += (i_val * i_val + q_val * q_val).sqrt();
            }
            let avg_mag = mag_sum / if_count as f32;
            let db = 10.0 * (avg_mag + 1e-12).log10();
            if db < self.squelch_level {
                // Mute: zero the IQ data (SDR++ memset to 0)
                for k in 0..if_count {
                    self.scratch_i[k] = 0.0;
                    self.scratch_q[k] = 0.0;
                }
            }
        }

        // ── Stage 5: FM Quadrature Demodulator ──────────────────────
        // (matches SDR++ dsp/demod/quadrature.h)
        self.scratch_audio.resize(if_count, 0.0);
        let mut prev_phase = self.prev_phase;
        for k in 0..if_count {
            let cur_phase = self.scratch_q[k].atan2(self.scratch_i[k]);
            let mut diff = cur_phase - prev_phase;
            // normalizePhase (single if/else, matches SDR++ math/normalize_phase.h)
            if diff > PI {
                diff -= 2.0 * PI;
            } else if diff <= -PI {
                diff += 2.0 * PI;
            }
            self.scratch_audio[k] = diff * self.inv_deviation;
            prev_phase = cur_phase;
        }
        self.prev_phase = prev_phase;

        // ── Stage 6: Post-Demod FIR Filter ──────────────────────────
        // (matches SDR++ dsp/demod/fm.h, lowPass at bandwidth/2)
        self.scratch_audio2.resize(if_count, 0.0);
        self.post_demod_fir.process_block(&self.scratch_audio, &mut self.scratch_audio2);

        // ── Stage 7: Audio Resampler (50 kHz → 48 kHz) ─────────────
        let mut audio_out: Vec<f32> = Vec::with_capacity(if_count + 16);
        self.audio_resampler.process(&self.scratch_audio2, &mut audio_out);

        // Copy to output buffer
        let out_count = audio_out.len().min(output.len());
        output[..out_count].copy_from_slice(&audio_out[..out_count]);
        out_count
    }
}

// ============================================================================
// Legacy DspProcessor compatibility — keep old API for non-NFM modes
// ============================================================================

// (The old DspProcessor is replaced by the new one above.
//  Non-FM modes like AM/SSB still use JS-side demod, so the new process()
//  method handles the full FM pipeline. For non-FM modes, worker.js can
//  use the raw IQ output via process_iq_only().)

#[wasm_bindgen]
impl DspProcessor {
    /// Process raw i8 IQ samples through NCO + decimation only.
    /// Returns interleaved complex f32 IQ pairs at IF sample rate (50 kHz).
    /// Used for non-FM modes (AM, SSB, CW, RAW) where JS handles demodulation.
    pub fn process_iq_only(&mut self, input: &[i8], output: &mut [f32]) -> usize {
        let num_iq = input.len() / 2;
        if num_iq == 0 {
            return 0;
        }

        // Stage 1: NCO (phasor rotation) — indexed writes for WASM perf
        if self.nco_buf_i.len() < num_iq {
            self.nco_buf_i.resize(num_iq, 0.0);
            self.nco_buf_q.resize(num_iq, 0.0);
        }

        let mut pr = self.phasor_re;
        let mut pi = self.phasor_im;
        let ir = self.phasor_inc_re;
        let ii = self.phasor_inc_im;

        let alpha = self.dc_alpha;
        let mut dc_i = self.dc_avg_i;
        let mut dc_q = self.dc_avg_q;

        for k in 0..num_iq {
            let mut i_val = input[k * 2] as f32 / 128.0;
            let mut q_val = input[k * 2 + 1] as f32 / 128.0;

            // DC Blocker (matches SDR++ genDCBlockRate)
            dc_i = dc_i * alpha + i_val * (1.0 - alpha);
            dc_q = dc_q * alpha + q_val * (1.0 - alpha);
            i_val -= dc_i;
            q_val -= dc_q;

            self.nco_buf_i[k] = i_val * pr - q_val * pi;
            self.nco_buf_q[k] = i_val * pi + q_val * pr;

            let new_r = pr * ir - pi * ii;
            let new_i = pr * ii + pi * ir;
            pr = new_r;
            pi = new_i;
        }

        self.dc_avg_i = dc_i;
        self.dc_avg_q = dc_q;

        let mag = (pr * pr + pi * pi).sqrt();
        self.phasor_re = pr / mag;
        self.phasor_im = pi / mag;

        // Stage 1b: CIC pre-decimation (fast in-place averaging)
        let mut cic_len = num_iq;
        for _ in 0..self.cic_stages {
            let half = cic_len / 2;
            for k in 0..half {
                self.nco_buf_i[k] = (self.nco_buf_i[2 * k] + self.nco_buf_i[2 * k + 1]) * 0.5;
                self.nco_buf_q[k] = (self.nco_buf_q[2 * k] + self.nco_buf_q[2 * k + 1]) * 0.5;
            }
            cic_len = half;
        }

        // Stage 1c: FIR anti-aliasing (final decimation stage)
        let decim_len = self.power_decim.process(cic_len, &self.nco_buf_i[..cic_len], &self.nco_buf_q[..cic_len]);

        // Stage 2: IQ Rational Resampler
        self.scratch_i.clear();
        self.scratch_q.clear();
        self.iq_resampler.process(
            &self.power_decim.output_i()[..decim_len], &self.power_decim.output_q()[..decim_len],
            &mut self.scratch_i, &mut self.scratch_q,
        );
        let if_count = self.scratch_i.len();

        // Stage 3: Channel filter
        if self.channel_filter_needed && if_count > 0 {
            self.scratch_i2.resize(if_count, 0.0);
            self.scratch_q2.resize(if_count, 0.0);
            self.channel_filter.process_block(
                &self.scratch_i, &self.scratch_q,
                &mut self.scratch_i2, &mut self.scratch_q2,
            );
            std::mem::swap(&mut self.scratch_i, &mut self.scratch_i2);
            std::mem::swap(&mut self.scratch_q, &mut self.scratch_q2);
        }

        // Output interleaved IQ pairs
        let out_count = (if_count * 2).min(output.len());
        let pairs = out_count / 2;
        for k in 0..pairs {
            output[k * 2] = self.scratch_i[k];
            output[k * 2 + 1] = self.scratch_q[k];
        }
        out_count
    }
}

// ============================================================================
// Rust Native Tests
// ============================================================================
#[cfg(test)]
mod tests {
    use super::*;

    /// Generate a unit (rectangular) window with no shaping
    fn ones_window(n: usize) -> Vec<f32> {
        vec![1.0; n]
    }

    #[test]
    fn test_fft_construction() {
        let n = 8;
        let window = ones_window(n);
        let fft = FFT::new(n, &window);

        assert_eq!(fft.n, n);
        // Internal fields are not directly accessible, but construction succeeding is OK
    }

    #[test]
    fn test_fft_set_smoothing_speed() {
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        fft.set_smoothing_speed(0.5);
        // Setting succeeds is OK (internal fields are private)
    }

    #[test]
    fn test_fft_dc_input() {
        // FFT test with DC-only input (all same values)
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        let mut input = vec![0i8; n * 2]; // Complex<i8> so n * 2
        for i in 0..n {
            input[i * 2] = 64; // real = 64
            input[i * 2 + 1] = 0; // imaginary = 0
        }

        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);

        // Results are rearranged to DC-centered, so DC component is at center (half_n)
        let half_n = n / 2;
        let dc_component = result.iter().enumerate().max_by(|a, b| {
            a.1.partial_cmp(b.1).unwrap()
        });

        // DC component should be at index 4 (half_n)
        assert_eq!(dc_component.unwrap().0, half_n);
    }

    #[test]
    fn test_fft_zero_input_should_not_produce_inf() {
        // All-zero input: should not produce log10(0) = -inf
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        let input = vec![0i8; n * 2]; // all zeros

        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);

        // All results should be finite (not inf, -inf, or NaN)
        for (i, &val) in result.iter().enumerate() {
            assert!(
                val.is_finite(),
                "result[{}] = {} is not finite (zero input should not produce inf)",
                i, val
            );
        }
    }

    #[test]
    fn test_fft_smoothing() {
        // Numerically verify the effect of smoothing
        // When smoothing_speed = 0.5 (SDR++ semantics):
        // result[k] = 0.5 * new_dB[k] + 0.5 * prev_dB[k]
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);
        fft.set_smoothing_speed(0.5);

        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = 64; // real = 64
            input[i * 2 + 1] = 0; // imaginary = 0
        }

        let mut result1 = vec![0.0f32; n];
        fft.fft(&input, &mut result1);

        let mut result2 = vec![0.0f32; n];
        fft.fft(&input, &mut result2);

        // With smoothing applied, the 2nd result should differ from the 1st
        // (because prev holds non-zero values)
        let mut differences_found = false;
        for i in 0..n {
            if result1[i].is_finite() && result2[i].is_finite() {
                let diff = (result1[i] - result2[i]).abs();
                // Values should have changed due to smoothing (tolerance 1e-6)
                if diff > 1e-6 {
                    differences_found = true;
                }
            }
        }
        assert!(
            differences_found,
            "Smoothing should produce different results on consecutive calls with same input"
        );
    }

    #[test]
    fn test_fft_smoothing_disabled_when_speed_is_one() {
        // Smoothing is disabled when smoothing_speed = 1.0 (SDR++ semantics: 1.0 = no smoothing)
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);
        // Default is 1.0 (no smoothing)

        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = 64;
            input[i * 2 + 1] = 0;
        }

        let mut result1 = vec![0.0f32; n];
        fft.fft(&input, &mut result1);

        let mut result2 = vec![0.0f32; n];
        fft.fft(&input, &mut result2);

        // Without smoothing, same input → same output
        for i in 0..n {
            if result1[i].is_finite() && result2[i].is_finite() {
                assert_eq!(
                    result1[i], result2[i],
                    "Without smoothing, same input should produce same output at index {}",
                    i
                );
            }
        }
    }

    #[test]
    fn test_fft_smoothing_edge_cases() {
        // Boundary value tests for smoothing_speed (SDR++ semantics)
        let n = 8;
        let window = ones_window(n);

        // 1.0: No smoothing (100% new value, tested above)

        // 0.0: Fully retain previous value (ignore new value, output frozen)
        let mut fft = FFT::new(n, &window);
        fft.set_smoothing_speed(0.0);

        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = 64;
            input[i * 2 + 1] = 0;
        }

        let mut result1 = vec![0.0f32; n];
        fft.fft(&input, &mut result1);

        let mut result2 = vec![0.0f32; n];
        fft.fft(&input, &mut result2);

        // When α=0.0, result2 should equal result1 (output is frozen)
        for i in 0..n {
            if result1[i].is_finite() && result2[i].is_finite() {
                assert_eq!(
                    result1[i], result2[i],
                    "With α=0.0, output should stay constant at index {}",
                    i
                );
            }
        }

        // Negative value: behavior is undefined but must not crash
        let mut fft = FFT::new(n, &window);
        fft.set_smoothing_speed(-0.5);
        let mut result = vec![0.0f32; n];
        // OK as long as it doesn't crash
        fft.fft(&input, &mut result);

        // Value greater than 1.0: may oscillate but must not crash
        let mut fft = FFT::new(n, &window);
        fft.set_smoothing_speed(1.5);
        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);
    }

    #[test]
    fn test_fft_dc_input_magnitude() {
        // Verify numerical correctness of FFT results for DC input
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        // DC component: all (64 + 0j)
        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = 64;
            input[i * 2 + 1] = 0;
        }

        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);

        // Theoretical calculation:
        // Input: 64/128 = 0.5
        // With (-1)^i window shift, DC signal becomes alternating → all energy at bin N/2
        // DC component after FFT: 0.5 * 8 = 4.0 (scaled by 1/(128*8)), magnitude = 0.5
        // Power: 0.5^2 = 0.25
        // dB: 10 * log10(0.25) ≈ -6.02
        let half_n = n / 2;
        let dc_value = result[half_n]; // DC component is at center

        let expected_db = 10.0 * (0.5_f32 * 0.5_f32).log10(); // ≈ -6.02
        assert!(
            (dc_value - expected_db).abs() < 0.1,
            "DC component {} should be close to {} (dB)",
            dc_value, expected_db
        );

        // DC component should be the maximum
        let max_idx = result
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .map(|(i, _)| i)
            .unwrap();
        assert_eq!(max_idx, half_n, "DC component should be at index {}", half_n);
    }

    #[test]
    fn test_fft_negative_input() {
        // Test with negative input values
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = -64; // negative value
            input[i * 2 + 1] = 0;
        }

        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);

        // All values should be finite
        for (i, &val) in result.iter().enumerate() {
            assert!(
                val.is_finite(),
                "result[{}] = {} is not finite (negative input should be handled)",
                i, val
            );
        }
    }

    #[test]
    fn test_fft_i8_boundary_values() {
        // Boundary value tests for i8
        let n = 8;
        let window = ones_window(n);
        let mut fft = FFT::new(n, &window);

        // i8::MIN = -128, i8::MAX = 127
        let test_values = [i8::MIN, -1, 0, 1, i8::MAX];

        for &val in &test_values {
            let mut input = vec![0i8; n * 2];
            for i in 0..n {
                input[i * 2] = val;
                input[i * 2 + 1] = 0;
            }

            let mut result = vec![0.0f32; n];
            fft.fft(&input, &mut result);

            // Should not crash, all values should be finite
            for (i, &r) in result.iter().enumerate() {
                assert!(
                    r.is_finite(),
                    "result[{}] = {} is not finite for input value {}",
                    i, r, val
                );
            }
        }
    }

    #[test]
    #[should_panic(expected = "Window size must match FFT size")]
    fn test_fft_window_size_mismatch() {
        let n = 8;
        let window = vec![1.0; 4]; // undersized
        let _fft = FFT::new(n, &window);
    }

    #[test]
    #[should_panic(expected = "Window size must match FFT size")]
    fn test_fft_window_size_oversized() {
        let n = 8;
        let window = vec![1.0; 16]; // oversized
        let _fft = FFT::new(n, &window);
    }

    #[test]
    #[should_panic(expected = "FFT size must be positive")]
    fn test_fft_zero_size() {
        let _fft = FFT::new(0, &[]);
    }

    #[test]
    #[should_panic(expected = "FFT size must be a power of two")]
    fn test_fft_non_power_of_two() {
        let n = 7; // not a power of two
        let window = vec![1.0; n];
        let _fft = FFT::new(n, &window);
    }

    #[test]
    #[should_panic(expected = "FFT size must be a power of two")]
    fn test_fft_odd_size() {
        let n = 9; // odd number
        let window = vec![1.0; n];
        let _fft = FFT::new(n, &window);
    }

    #[test]
    fn test_fft_differential_against_reference() {
        // Compare results between reference (naive) implementation and optimized version
        let n = 16;
        let mut window = vec![0.0f32; n];
        for (i, w) in window.iter_mut().enumerate() {
             // Generate a Hann-like window
             *w = 0.5 * (1.0 - (2.0 * std::f32::consts::PI * i as f32 / (n - 1) as f32).cos());
        }
        
        let mut fft = FFT::new(n, &window);
        fft.set_smoothing_speed(0.3);
        
        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i*2] = (i as i8).wrapping_sub(8).wrapping_mul(10);
            input[i*2+1] = (7i8).wrapping_sub(i as i8).wrapping_mul(10);
        }
        
        // First run (updating prev from zero)
        let mut result_opt = vec![0.0f32; n];
        fft.fft(&input, &mut result_opt);
        
        // Reference calculation (1st run)
        let mut prev = vec![0.0f32; n]; // initial state
        let expected = calculate_reference_fft(n, &window, &input, &mut prev, 0.3);
        
        for i in 0..n {
            assert!((result_opt[i] - expected[i]).abs() < 1e-5, "Mismatch at index {} on 1st run: opt={}, expected={}", i, result_opt[i], expected[i]);
        }
        
        // Second run (verify smoothing effect)
        fft.fft(&input, &mut result_opt);
        let expected2 = calculate_reference_fft(n, &window, &input, &mut prev, 0.3);
        
        for i in 0..n {
            assert!((result_opt[i] - expected2[i]).abs() < 1e-5, "Mismatch at index {} on 2nd run: opt={}, expected={}", i, result_opt[i], expected2[i]);
        }
    }

    /// Naive reference calculation matching SDR++ pipeline (efficiency ignored)
    fn calculate_reference_fft(n: usize, window: &[f32], input: &[i8], prev: &mut [f32], alpha: f32) -> Vec<f32> {
        use rustfft::num_complex::Complex;
        // Apply window with (-1)^i shift and scaling (matches SDR++ iq_frontend.cpp)
        let scale = 1.0 / (128.0 * n as f32);
        let mut buffer = vec![Complex { re: 0.0, im: 0.0 }; n];
        for i in 0..n {
            let shift = if i % 2 == 0 { 1.0f32 } else { -1.0f32 };
            buffer[i] = Complex {
                re: input[i*2] as f32,
                im: input[i*2+1] as f32,
            } * (window[i] * scale * shift);
        }
        
        let mut planner = FftPlanner::new();
        let fft = planner.plan_fft_forward(n);
        fft.process(&mut buffer);
        
        // Power spectrum + dB + smoothing in dB domain (matches SDR++ waterfall.cpp)
        let mut res = vec![0.0f32; n];
        for i in 0..n {
            let power = buffer[i].norm_sqr();
            let db = power.max(1e-20).log10() * 10.0;
            
            res[i] = if alpha < 1.0 {
                let s = alpha * db + (1.0 - alpha) * prev[i];
                prev[i] = s;
                s
            } else {
                db
            };
        }
        res
    }
}

// ============================================================================
// Wasm Tests (wasm-bindgen-test)
// ============================================================================
#[cfg(test)]
mod wasm_tests {
    use super::*;
    use wasm_bindgen_test::wasm_bindgen_test;

    #[wasm_bindgen_test]
    fn test_fft_construction_wasm() {
        let n = 8;
        let window = vec![1.0; n];
        let _fft = FFT::new(n, &window);
    }

    #[wasm_bindgen_test]
    fn test_fft_processing_wasm() {
        let n = 8;
        let window = vec![1.0; n];
        let mut fft = FFT::new(n, &window);

        let mut input = vec![0i8; n * 2];
        for i in 0..n {
            input[i * 2] = 64;
            input[i * 2 + 1] = 0;
        }

        let mut result = vec![0.0f32; n];
        fft.fft(&input, &mut result);

        // Verify the result size is correct
        assert_eq!(result.len(), n);
    }
}
